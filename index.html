<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D模型 | 交互展示系统</title>
    <link rel="stylesheet" href="css/font-awesome/css/all.min.css">
    <script src="./js/libs/pako/pako.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Segoe UI', 'Roboto', sans-serif;
            background: linear-gradient(135deg, #0a0a0f 0%, #151522 100%);
            color: #e0e0ff;
            min-height: 100vh;
            overflow-x: hidden;
        }
        
        .container {
            display: grid;
            grid-template-columns: 1fr 380px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 0;
            max-width: 100%;
            padding: 0;
        }
        
        /* 头部样式 */
        header {
            grid-column: 1 / span 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px 30px;
            background: rgba(10, 10, 20, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(100, 150, 255, 0.1);
            z-index: 100;
        }
        
        .logo {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .logo-icon {
            font-size: 1.8rem;
            color: #4dabf7;
            background: linear-gradient(90deg, #4dabf7, #748ffc);
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .logo-text h1 {
            font-size: 1.8rem;
            font-weight: 700;
            background: linear-gradient(90deg, #ffffff, #a5d8ff);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            letter-spacing: 1px;
        }
        
        .logo-text p {
            font-size: 0.85rem;
            color: #8a9bb8;
            margin-top: 3px;
        }
        
        .header-controls {
            display: flex;
            align-items: center;
            gap: 15px;
        }
        
        .model-select-container {
            position: relative;
            min-width: 200px;
        }
        
        .model-select {
            width: 100%;
            padding: 10px 15px;
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(100, 150, 255, 0.2);
            color: #c5d5ff;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9rem;
            appearance: none;
            -webkit-appearance: none;
            -moz-appearance: none;
            padding-right: 35px;
            transition: all 0.3s ease;
        }
        
        .model-select:hover {
            background: rgba(56, 189, 248, 0.1);
            border-color: rgba(56, 189, 248, 0.4);
        }
        
        .model-select:focus {
            outline: none;
            border-color: rgba(56, 189, 248, 0.8);
            box-shadow: 0 0 10px rgba(56, 189, 248, 0.3);
        }
        
        .model-select-arrow {
            position: absolute;
            right: 12px;
            top: 50%;
            transform: translateY(-50%);
            color: #4dabf7;
            pointer-events: none;
        }
        
        .view-controls {
            display: flex;
            gap: 12px;
        }
        
        .view-btn {
            padding: 10px 20px;
            background: rgba(30, 41, 59, 0.7);
            border: 1px solid rgba(100, 150, 255, 0.2);
            color: #c5d5ff;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .view-btn:hover {
            background: rgba(56, 189, 248, 0.2);
            border-color: rgba(56, 189, 248, 0.5);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(56, 189, 248, 0.2);
        }
        
        .view-btn.active {
            background: rgba(56, 189, 248, 0.3);
            border-color: rgba(56, 189, 248, 0.8);
            box-shadow: 0 0 15px rgba(56, 189, 248, 0.4);
        }
        
        /* 3D视图区域 */
        .viewer-section {
            position: relative;
            overflow: hidden;
            background: #0a0a0f;
        }
        
        #three-container {
            width: 100%;
            height: 100%;
        }
        
        .viewer-overlay {
            position: absolute;
            bottom: 30px;
            left: 30px;
            background: rgba(10, 10, 20, 0.7);
            backdrop-filter: blur(10px);
            border-radius: 12px;
            padding: 15px 20px;
            border: 1px solid rgba(100, 150, 255, 0.1);
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.4);
        }
        
        .model-info h3 {
            font-size: 1.1rem;
            margin-bottom: 5px;
            color: #a5d8ff;
        }
        
        .model-info p {
            font-size: 0.9rem;
            color: #8a9bb8;
        }
        
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            z-index: 10;
        }
        
        /* 拖动浏览提示 */
        .drag-hint {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(0, 30, 60, 0.7);
            color: #ffffff;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 1px solid rgba(77, 171, 247, 0.5);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
            z-index: 5;
        }
        
        .drag-hint i {
            color: #4dabf7;
            font-size: 1rem;
        }
        
        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(77, 171, 247, 0.2);
            border-top: 4px solid #4dabf7;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* 控制面板 */
        .controls-section {
            background: rgba(15, 23, 42, 0.9);
            backdrop-filter: blur(10px);
            padding: 30px;
            border-left: 1px solid rgba(100, 150, 255, 0.1);
            overflow-y: auto;
            box-shadow: -10px 0 30px rgba(0, 0, 0, 0.3);
        }
        
        .controls-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 1px solid rgba(100, 150, 255, 0.2);
        }
        
        .controls-header i {
            font-size: 1.3rem;
            color: #4dabf7;
        }
        
        .controls-header h2 {
            font-size: 1.5rem;
            font-weight: 600;
            background: linear-gradient(90deg, #a5d8ff, #748ffc);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
        }
        
        .control-group {
            background: rgba(30, 41, 59, 0.6);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 20px;
            border: 1px solid rgba(100, 150, 255, 0.1);
            transition: all 0.3s ease;
        }
        
        .control-group:hover {
            border-color: rgba(100, 150, 255, 0.3);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
        }
        
        .control-title {
            display: flex;
            align-items: center;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .control-title i {
            color: #4dabf7;
            font-size: 1.1rem;
        }
        
        .control-title h3 {
            font-size: 1.1rem;
            font-weight: 600;
            color: #c5d5ff;
        }
        
        .slider-container {
            margin-bottom: 15px;
        }
        
        .slider-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 10px;
            font-size: 0.9rem;
            color: #a5d5ff;
        }
        
        .slider-value {
            color: #4dabf7;
            font-weight: 600;
        }
        
        .slider {
            width: 100%;
            height: 6px;
            -webkit-appearance: none;
            background: linear-gradient(90deg, rgba(77, 171, 247, 0.2), rgba(77, 171, 247, 0.8));
            border-radius: 3px;
            outline: none;
        }
        
        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: #4dabf7;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(77, 171, 247, 0.8);
            border: 2px solid #ffffff;
        }
        
        .toggle-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-top: 10px;
        }
        
        .toggle-label {
            font-size: 0.95rem;
            color: #c5d5ff;
        }
        
        .toggle-switch {
            position: relative;
            width: 50px;
            height: 26px;
        }
        
        .toggle-switch input {
            opacity: 0;
            width: 0;
            height: 0;
        }
        
        .toggle-slider {
            position: absolute;
            cursor: pointer;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background-color: rgba(100, 150, 255, 0.2);
            border-radius: 34px;
            transition: .4s;
        }
        
        .toggle-slider:before {
            position: absolute;
            content: "";
            height: 18px;
            width: 18px;
            left: 4px;
            bottom: 4px;
            background-color: #8a9bb8;
            border-radius: 50%;
            transition: .4s;
        }
        
        input:checked + .toggle-slider {
            background-color: rgba(77, 171, 247, 0.5);
        }
        
        input:checked + .toggle-slider:before {
            transform: translateX(24px);
            background-color: #4dabf7;
        }
        
        .instructions {
            background: linear-gradient(135deg, rgba(30, 41, 59, 0.8), rgba(15, 23, 42, 0.8));
            border-radius: 12px;
            padding: 20px;
            margin-top: 25px;
            border-left: 4px solid #4dabf7;
        }
        
        .instructions h3 {
            color: #a5d8ff;
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .instructions ul {
            list-style: none;
            padding-left: 0;
        }
        
        .instructions li {
            margin-bottom: 10px;
            padding-left: 25px;
            position: relative;
            color: #8a9bb8;
            line-height: 1.5;
        }
        
        .instructions li:before {
            content: "•";
            color: #4dabf7;
            font-size: 1.5rem;
            position: absolute;
            left: 0;
            top: -5px;
        }
        
        /* 文件上传按钮样式 */
        .file-upload-btn {
            display: inline-block;
            padding: 12px 24px;
            background: linear-gradient(135deg, #4dabf7 0%, #748ffc 100%);
            color: white;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            text-align: center;
            transition: all 0.3s ease;
            border: none;
            width: 100%;
            margin-top: 10px;
        }
        
        .file-upload-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 20px rgba(77, 171, 247, 0.4);
        }
        
        .file-upload-btn i {
            margin-right: 8px;
        }
        
        #model-file, #hdr-file {
            display: none;
        }
        
        /* HDR上传信息显示 */
        .hdr-info {
            background: rgba(20, 30, 50, 0.8);
            border-radius: 8px;
            padding: 10px;
            margin-top: 10px;
            font-size: 0.85rem;
            display: none;
        }
        
        .hdr-info.visible {
            display: block;
        }
        
        .hdr-info-item {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
        }
        
        .hdr-info-label {
            color: #a5d8ff;
        }
        
        .hdr-info-value {
            color: #4dabf7;
            font-weight: 600;
            max-width: 150px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        
        /* 底部状态栏 */
        footer {
            grid-column: 1 / span 2;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px 30px;
            background: rgba(10, 10, 20, 0.8);
            border-top: 1px solid rgba(100, 150, 255, 0.1);
            font-size: 0.85rem;
            color: #8a9bb8;
        }
        
        .status-indicators {
            display: flex;
            gap: 20px;
        }
        
        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background-color: #10b981;
        }
        
        .status-dot.warning {
            background-color: #f59e0b;
        }
        
        .door-status-dot {
            background-color: #8a9bb8;
        }
        
        /* 移动端控制面板切换按钮 */
        .mobile-controls-toggle {
            display: none;
            position: absolute;
            top: 100px;
            right: 20px;
            z-index: 1000;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: linear-gradient(135deg, #4dabf7 0%, #748ffc 100%);
            color: white;
            border: none;
            font-size: 1.2rem;
            cursor: pointer;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        
        /* 响应式调整 */
        @media (max-width: 1100px) {
            .container {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr auto auto;
            }
            
            .controls-section {
                position: fixed;
                top: 0;
                right: -400px;
                width: 380px;
                height: 100vh;
                z-index: 999;
                transition: right 0.3s ease;
                border-left: none;
                border-top: 1px solid rgba(100, 150, 255, 0.1);
                max-height: none;
                overflow-y: auto;
            }
            
            .controls-section.active {
                right: 0;
                box-shadow: -10px 0 30px rgba(0, 0, 0, 0.5);
            }
            
            header, footer {
                grid-column: 1;
            }
            
            .mobile-controls-toggle {
                display: flex;
                align-items: center;
                justify-content: center;
            }
            
            /* 移动端优化 */
            .viewer-section {
                grid-row: 2;
                height: calc(100vh - 130px);
            }
            
            header {
                padding: 15px 20px;
                flex-wrap: wrap;
                gap: 15px;
            }
            
            .header-controls {
                order: 3;
                width: 100%;
                justify-content: space-between;
            }
            
            .model-select-container {
                min-width: 150px;
            }
            
            .logo-text h1 {
                font-size: 1.4rem;
            }
            
            .view-btn {
                padding: 8px 15px;
                font-size: 0.9rem;
            }
            
            footer {
                padding: 10px 15px;
                font-size: 0.8rem;
                flex-wrap: wrap;
                gap: 10px;
            }
            
            .status-indicators {
                gap: 10px;
            }
            
            .viewer-overlay {
                bottom: 20px;
                left: 20px;
                right: 20px;
                padding: 12px 15px;
            }
        }
        
        @media (max-width: 768px) {
            .controls-section {
                width: 100%;
                right: -100%;
            }
            
            .view-controls {
                flex-wrap: wrap;
                justify-content: flex-end;
            }
            
            .view-btn {
                flex: 1;
                min-width: 120px;
                justify-content: center;
            }
            
            .logo-text h1 {
                font-size: 1.2rem;
            }
            
            .logo-text p {
                font-size: 0.75rem;
            }
            
            .viewer-section {
                height: calc(100vh - 120px);
            }
        }
        
        @media (max-width: 480px) {
            header {
                padding: 12px 15px;
            }
            
            .logo-text h1 {
                font-size: 1.1rem;
            }
            
            .view-btn {
                padding: 6px 10px;
                font-size: 0.8rem;
                min-width: auto;
            }
            
            .model-select {
                padding: 8px 12px;
                font-size: 0.8rem;
            }
            
            .viewer-overlay {
                bottom: 15px;
                left: 15px;
                right: 15px;
                padding: 10px 12px;
            }
            
            .model-info h3 {
                font-size: 1rem;
            }
            
            .model-info p {
                font-size: 0.8rem;
            }
            
            footer {
                flex-direction: column;
                align-items: flex-start;
                gap: 10px;
            }
        }
        
        /* 自定义滚动条 */
        .controls-section::-webkit-scrollbar {
            width: 8px;
        }
        
        .controls-section::-webkit-scrollbar-track {
            background: rgba(30, 41, 59, 0.3);
            border-radius: 4px;
        }
        
        .controls-section::-webkit-scrollbar-thumb {
            background: rgba(77, 171, 247, 0.5);
            border-radius: 4px;
        }
        
        .controls-section::-webkit-scrollbar-thumb:hover {
            background: rgba(77, 171, 247, 0.8);
        }
        
        /* 播放按钮覆盖层 */
        .play-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: url('images/cover.jpg') center center no-repeat;
            background-size: cover;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 9999;
            transition: opacity 0.8s ease;
            pointer-events: auto;
            overflow: hidden;
        }
        
        .play-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }
        
        /* 主标题 */
        .main-title {
            font-size: 4rem;
            font-weight: 800;
            color: #ffffff;
            background: rgba(0, 30, 60, 0.6);
            padding: 20px 60px;
            border: 3px solid #4dabf7;
            border-radius: 15px;
            box-shadow: 0 0 30px rgba(77, 171, 247, 0.8),
                        0 0 60px rgba(77, 171, 247, 0.4);
            margin-bottom: 150px;
            margin-top: -100px;
            letter-spacing: 8px;
            z-index: 10;
        }
        
        @keyframes gradient {
            0%, 100% { background-position: 0% center; }
            50% { background-position: 200% center; }
        }
        
        /* 旋转光环容器 */
        .rings-container {
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }
        
        /* 旋转光环 */
        .ring {
            position: absolute;
            border-radius: 50%;
            border: 4px solid transparent;
            border-top-color: #66ccff;
            border-right-color: #66ccff;
            animation: spin 2s linear infinite;
            box-shadow: 0 0 20px rgba(102, 204, 255, 0.8),
                        0 0 40px rgba(102, 204, 255, 0.4);
        }
        
        .ring:nth-child(1) {
            width: 200px;
            height: 200px;
        }
        
        .ring:nth-child(2) {
            width: 230px;
            height: 230px;
            animation: spin 3s linear infinite reverse;
            opacity: 0.7;
            border-top-color: #88aaff;
            border-right-color: #88aaff;
            box-shadow: 0 0 20px rgba(136, 170, 255, 0.6),
                        0 0 40px rgba(136, 170, 255, 0.3);
        }
        
        .ring:nth-child(3) {
            width: 260px;
            height: 260px;
            animation: spin 4s linear infinite;
            opacity: 0.5;
            border-top-color: #aaddff;
            border-right-color: #aaddff;
            box-shadow: 0 0 20px rgba(170, 221, 255, 0.4),
                        0 0 40px rgba(170, 221, 255, 0.2);
        }
        
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        
        /* 圆形播放按钮 */
        .play-button {
            position: relative;
            width: 150px;
            height: 150px;
            border-radius: 50%;
            background: rgba(0, 30, 60, 0.7);
            border: 3px solid #4dabf7;
            cursor: pointer;
            box-shadow: 0 0 40px rgba(77, 171, 247, 0.6),
                        0 0 80px rgba(77, 171, 247, 0.3);
            transition: all 0.3s ease;
            z-index: 10;
        }
        
        .play-button:hover {
            transform: scale(1.1);
            background: rgba(77, 171, 247, 0.5);
            box-shadow: 0 0 60px rgba(77, 171, 247, 0.8),
                        0 0 100px rgba(77, 171, 247, 0.5);
        }
        
        .play-button:active {
            transform: scale(0.95);
        }
        
        /* 三角形播放图标 */
        .play-icon {
            position: absolute;
            top: 50%;
            left: 55%;
            transform: translate(-50%, -50%);
            width: 0;
            height: 0;
            border-top: 25px solid transparent;
            border-bottom: 25px solid transparent;
            border-left: 40px solid #ffffff;
        }
        
        /* 按钮标题 */
        .play-title {
            margin-top: 40px;
            color: #ffffff;
            font-size: 1.2rem;
            text-align: center;
            z-index: 10;
            text-shadow: 0 0 20px rgba(77, 171, 247, 0.8);
        }
        
        /* 控制面板遮罩 */
        .controls-overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            z-index: 998;
            backdrop-filter: blur(3px);
        }
        
        .controls-overlay.active {
            display: block;
        }
        
        /* 播放按钮覆盖层 - 手机端适配 */
        @media (max-width: 768px) {
            .main-title {
                font-size: 0.9rem !important;
                padding: 7px 12px !important;
                margin-bottom: 100px;
                margin-top: -50px;
                letter-spacing: 0.5px !important;
                white-space: nowrap !important;
            }
            
            .play-button {
                width: 120px;
                height: 120px;
            }
            
            .play-icon {
                border-top: 20px solid transparent;
                border-bottom: 20px solid transparent;
                border-left: 32px solid #ffffff;
            }
            
            .play-title {
                font-size: 1rem;
                margin-top: 30px;
            }
            
            .ring:nth-child(1) {
                width: 160px;
                height: 160px;
            }
            
            .ring:nth-child(2) {
                width: 185px;
                height: 185px;
            }
            
            .ring:nth-child(3) {
                width: 210px;
                height: 210px;
            }
        }
        
        @media (max-width: 480px) {
            .main-title {
                font-size: 2.0rem !important;
                padding: 12px 24px !important;
                margin-bottom: 80px;
                margin-top: -120px;
                letter-spacing: 0px !important;
                white-space: nowrap !important;
            }
            
            .play-button {
                width: 100px;
                height: 100px;
            }
            
            .play-icon {
                border-top: 16px solid transparent;
                border-bottom: 16px solid transparent;
                border-left: 26px solid #ffffff;
            }
            
            .play-title {
                font-size: 1.2rem;
                margin-top: 25px;
            }
            
            .ring:nth-child(1) {
                width: 130px;
                height: 130px;
            }
            
            .ring:nth-child(2) {
                width: 155px;
                height: 155px;
            }
            
            .ring:nth-child(3) {
                width: 180px;
                height: 180px;
            }
        }
    </style>
</head>
<body>
    <!-- 背景音乐 -->
    <audio id="bg-music" preload="auto" loop>
        <source src="" type="audio/mpeg">
    </audio>
    
    <!-- 播放按钮覆盖层 -->
    <div id="play-overlay" class="play-overlay">
        <h1 class="main-title">3D模型交互展示系统</h1>
        <div class="rings-container">
            <div class="ring"></div>
            <div class="ring"></div>
            <div class="ring"></div>
            <button class="play-button" id="play-button">
                <div class="play-icon"></div>
            </button>
        </div>
        <div class="play-title">开始</div>
    </div>
    
    <div id="main-container" class="container">
        <header>
            <div class="logo">
                <div class="logo-icon">
                    <i class="fas fa-cube"></i>
                </div>
                <div class="logo-text">
                    <h1>3D模型展示系统</h1>
                    <p>沉浸式交互式产品 | 材质识别 | 实时渲染</p>
                </div>
            </div>
            
            <div class="header-controls">
                <div class="model-select-container">
                    <select id="model-select" class="model-select">
                        <option value="" disabled selected>选择模型...</option>
                        <!-- 模型选项将通过JavaScript动态生成 -->
                    </select>
                    <div class="model-select-arrow">
                        <i class="fas fa-chevron-down"></i>
                    </div>
                </div>
                
                <div class="view-controls">
                    <button id="toggle-music-btn" class="view-btn">
                        <i class="fas fa-music"></i>
                        <span>背景音乐</span>
                    </button>
                    <button id="toggle-lights-btn" class="view-btn">
                        <i class="fas fa-lightbulb"></i>
                        <span>泛光灯照明</span>
                    </button>
                </div>
            </div>
        </header>
        
        <section class="viewer-section">
            <div id="three-container"></div>
            <div class="viewer-overlay">
                <div class="model-info">
                    <h3 id="model-name">模型展示</h3>
                    <p id="model-description">金属/玻璃/油漆复合材质 | 支持交互</p>
                </div>
            </div>
            
            <!-- 拖动浏览提示 -->
            <div class="drag-hint">
                <i class="fas fa-mouse"></i>
                <span>可拖动整体旋转，可拖动活动部件</span>
            </div>
            
            <div class="loading" id="loading" style="display: none;">
                <div class="spinner"></div>
                <p id="loading-text">正在加载模型...</p>
                <div class="progress-bar-wrap" style="width: 200px; height: 8px; background: rgba(77,171,247,0.2); border-radius: 4px; overflow: hidden;">
                    <div id="loading-progress" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4dabf7, #748ffc); border-radius: 4px; transition: width 0.2s;"></div>
                </div>
                <p id="loading-percent" style="font-size: 0.9rem; color: #8a9bb8;">0%</p>
            </div>
        </section>
        
        <button class="mobile-controls-toggle" id="mobile-controls-toggle">
            <i class="fas fa-sliders-h"></i>
        </button>
        
        <div class="controls-overlay" id="controls-overlay"></div>
        
        <section class="controls-section" id="controls-section">
            <div class="controls-header">
                <i class="fas fa-sliders-h"></i>
                <h2>材质与效果控制</h2>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-gem"></i>
                    <h3>金属材质设置</h3>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>金属反射</span>
                        <span class="slider-value" id="metalness-value">0.6</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" value="0.6" class="slider" id="metalness-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>金属粗糙度</span>
                        <span class="slider-value" id="metal-roughness-value">0.2</span>
                    </div>
                    <input type="range" min="0" max="1" step="0.05" value="0.2" class="slider" id="metal-roughness-slider">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-paint-brush"></i>
                    <h3>油漆材质设置</h3>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>油漆亮度</span>
                        <span class="slider-value" id="paint-brightness-value">0.8</span>
                    </div>
                    <input type="range" min="0.1" max="2.0" step="0.1" value="0.8" class="slider" id="paint-brightness-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>油漆粗糙度</span>
                        <span class="slider-value" id="paint-roughness-value">0.35</span>
                    </div>
                    <input type="range" min="0.1" max="1.0" step="0.05" value="0.35" class="slider" id="paint-roughness-slider">
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-sun"></i>
                    <h3>灯光与环境</h3>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>主光源强度</span>
                        <span class="slider-value" id="light-intensity-value">1.5</span>
                    </div>
                    <input type="range" min="0.5" max="5.0" step="0.1" value="1.5" class="slider" id="light-intensity-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>左辅助光（冷色）</span>
                        <span class="slider-value" id="left-light-value">0.6</span>
                    </div>
                    <input type="range" min="0" max="2.0" step="0.1" value="0.6" class="slider" id="left-light-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>右辅助光</span>
                        <span class="slider-value" id="right-light-value">0.6</span>
                    </div>
                    <input type="range" min="0" max="2.0" step="0.1" value="0.6" class="slider" id="right-light-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>环境光强度</span>
                        <span class="slider-value" id="env-intensity-value">0.7</span>
                    </div>
                    <input type="range" min="0" max="2" step="0.1" value="0.7" class="slider" id="env-intensity-slider">
                </div>
                
                <div style="margin-top: 15px;">
                    <p style="color: #8a9bb8; font-size: 0.9rem; margin-bottom: 10px;">
                        选择HDR环境贴图
                    </p>
                    
                    <div class="model-select-container">
                        <select id="hdr-select" class="model-select">
                            <option value="" disabled selected>选择环境贴图...</option>
                            <!-- 环境贴图选项将通过JavaScript动态生成 -->
                        </select>
                        <div class="model-select-arrow">
                            <i class="fas fa-chevron-down"></i>
                        </div>
                    </div>
                    
                    <div class="hdr-info" id="hdr-info">
                        <div class="hdr-info-item">
                            <span class="hdr-info-label">当前环境:</span>
                            <span class="hdr-info-value" id="current-hdr-name">默认环境</span>
                        </div>
                    </div>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-magic"></i>
                    <h3>辉光效果</h3>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>辉光强度</span>
                        <span class="slider-value" id="bloom-strength-value">0.5</span>
                    </div>
                    <input type="range" min="0" max="2.0" step="0.1" value="0.5" class="slider" id="bloom-strength-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>辉光阈值</span>
                        <span class="slider-value" id="bloom-threshold-value">2.0</span>
                    </div>
                    <input type="range" min="0.5" max="3.0" step="0.05" value="2.0" class="slider" id="bloom-threshold-slider">
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>辉光半径</span>
                        <span class="slider-value" id="bloom-radius-value">0.6</span>
                    </div>
                    <input type="range" min="0.1" max="1.5" step="0.1" value="0.6" class="slider" id="bloom-radius-slider">
                </div>
                
                <div class="toggle-container">
                    <span class="toggle-label">启用辉光</span>
                    <label class="toggle-switch">
                        <input type="checkbox" id="bloom-enabled-toggle" checked>
                        <span class="toggle-slider"></span>
                    </label>
                </div>
            </div>
            
            <div class="control-group">
                <div class="control-title">
                    <i class="fas fa-shadows"></i>
                    <h3>阴影优化</h3>
                </div>
                
                <div class="slider-container">
                    <div class="slider-label">
                        <span>阴影模糊</span>
                        <span class="slider-value" id="shadow-blur-value">8.0</span>
                    </div>
                    <input type="range" min="0" max="50" step="0.1" value="8.0" class="slider" id="shadow-blur-slider">
                </div>
                

            </div>
            
            <div class="instructions">
                <h3><i class="fas fa-info-circle"></i> 交互指南</h3>
                <ul>
                    <li><strong>鼠标拖动</strong> - 旋转查看模型</li>
                    <li><strong>鼠标滚轮</strong> - 缩放模型大小</li>
                    <li><strong>点击任一显示屏</strong> - 点亮所有显示屏（增强贴图效果）</li>
                    <li><strong>点击任一灯带</strong> - 点亮所有灯带（带光晕效果）</li>
                    <li><strong>左右拖动柜门(CabinetDoor_left/right)</strong> - 打开/关闭柜门（绕Z轴旋转85°）</li>
                    <li><strong>上下拖动抽屉(Drawer1/2)</strong> - 打开/关闭抽屉（沿Y轴移动-200mm）</li>
                       <li><strong>泛光灯照明</strong> - 采用泛光灯加左右辅助光系统</li>
                    <li><strong>模型切换</strong> - 使用顶部下拉菜单选择不同模型</li>
                </ul>
            </div>
        </section>
        
        <footer>
            <div class="copyright">
                <p>&copy; 2026 3D模型展示系统 | 基于Three.js构建 | 增强版</p>
            </div>
            <div class="status-indicators">
                <div class="status-item">
                    <div class="status-dot" id="model-status"></div>
                    <span id="model-status-text">模型加载中</span>
                </div>
                <div class="status-item">
                    <div class="status-dot warning" id="interaction-status"></div>
                    <span id="interaction-status-text">屏幕关闭</span>
                </div>
                <div class="status-item">
                    <div class="status-dot door-status-dot" id="door-status"></div>
                    <span id="door-status-text">柜门关闭</span>
                </div>
            </div>
        </footer>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "./js/three.module.js",
                "three/addons/": "./js/three/addons/",
                "three/addons/loaders/DRACOLoader.js": "./js/libs/draco/DRACOLoader.js"
            }
        }
    </script>
    
    <script type="module">
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { DRACOLoader } from './js/libs/draco/DRACOLoader.js';
    import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
    import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
    import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
    import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
    import { OutlinePass } from 'three/addons/postprocessing/OutlinePass.js';
    import { MeshoptDecoder } from './js/libs/meshopt/meshopt_decoder.module.js';
    
    // 全局变量
    let scene, camera, renderer, controls, composer, bloomPass, outlinePass;
    let model = null;
    let shadowCatcher = null;
        let clock = new THREE.Clock();
    let raycaster = new THREE.Raycaster();
    let mouse = new THREE.Vector2();
    let envMap = null;
    let omniLights = [];
    
    // Web Worker 相关
    let modelWorker = null;
    let isWorkerInitialized = false;
    
    // 灯光参数
    let mainLightIntensity = 1.5;
    let leftLightIntensity = 0.6;
    let rightLightIntensity = 0.6;
    let envIntensity = 0.7;
    
    // 金属材质参数
    let metalness = 0.6;
    let metalRoughness = 0.2;
    
    // 油漆材质参数
    let paintBrightness = 0.8;
    let paintRoughness = 0.35;
    
    // 辉光参数
let bloomStrength = 0.5;
let bloomThreshold = 2.0;
let bloomRadius = 0.6;
let bloomEnabled = true;
    
    // 屏幕参数
    let screenOffBrightness = 0.1;
    let screenOnBrightness = 2.0;

    // 材质映射
    let materialGroups = {
        metal: [],
        paint: [],
        screen: [],
        door: [],
        drawer: []
    };
    
    // 特殊材质引用
    let ddMaterialMeshes = [];
    
    // 灯光引用
    let mainLight, leftFillLight, rightFillLight, ambientLight;
    let pointLight1, pointLight2, pointLight3; // 三个点光源
    
    // 柜门状态 - 85°
    let cabinetDoors = [];
    const doorOpenAngle = 85 * (Math.PI / 180); // 85度
    
    // 抽屉状态
    let drawers = [];
    const drawerMoveDistance = -200;
    
    // 推拉门状态
    let slidingDoors = [];
    
    // 自动演示相关
    let isAutoPlaying = false;
    let isModelRotating = false;
    let modelRotationSpeed = (2 * Math.PI) / 20; // 20秒旋转一周
    
    // 模型加载状态
    let isModelLoading = false;
    
    // 拖动相关
    let isDragging = false;
    let draggedObject = null;
    let dragStartMouse = new THREE.Vector2();
    let dragStartPosition = new THREE.Vector3();
    let dragStartRotation = new THREE.Euler();
    
    // 模型列表（初始为空，将通过检测本地models文件夹动态填充）
    let modelList = [];
    
    // 环境贴图列表
    const envMapList = [
        {
            id: 'default',
            name: '默认环境',
            path: null
        },
        {
            id: 'env1',
            name: '工作室环境',
            path: 'env/studio.hdr'
        },
        {
            id: 'env2',
            name: '户外环境',
            path: 'env/outdoor.hdr'
        },
        {
            id: 'env3',
            name: '夜晚环境',
            path: 'env/night.hdr'
        },
        {
            id: 'env4',
            name: '工业环境',
            path: 'env/industrial.hdr'
        }
    ];
    
    // Draco 解码器（用于带 KHR_draco_mesh_compression 的 GLB）
    let dracoLoader = null;
    function getDracoLoader() {
        if (!dracoLoader) {
            dracoLoader = new DRACOLoader();
            dracoLoader.setDecoderPath('./js/libs/draco/');
        }
        return dracoLoader;
    }
    
    // 更新加载进度条
    function setLoadingProgress(percent, text) {
        const el = document.getElementById('loading-progress');
        const percentEl = document.getElementById('loading-percent');
        const textEl = document.getElementById('loading-text');
        const clampedPercent = Math.min(100, Math.max(0, percent));
        if (el) el.style.width = clampedPercent + '%';
        if (percentEl) percentEl.textContent = Math.round(clampedPercent) + '%';
        if (textEl && text) textEl.textContent = text;
    }
    
    // 初始化 Web Worker
    function initModelWorker() {
        if (!modelWorker) {
            try {
                // 创建Web Worker，使用相对路径
                // 确保Web Worker文件存在且正确
                const workerUrl = './model-loader.worker.js';
                
                // 检查Web Worker文件是否存在
                const xhr = new XMLHttpRequest();
                xhr.open('HEAD', workerUrl, false);
                xhr.send();
                
                if (xhr.status === 200) {
                    modelWorker = new Worker(workerUrl);
                    
                    modelWorker.onmessage = function(e) {
                        const { type, progress, status, modelPath, modelData, error } = e.data;
                        
                        switch (type) {
                            case 'progress':
                                setLoadingProgress(progress, status);
                                break;
                            case 'complete':
                                if (modelData) {
                                    // 使用Web Worker返回的模型数据
                                    loadModelFromWorker(modelData);
                                } else if (modelPath) {
                                    // 模型加载完成，开始实际的模型处理
                                    loadModelActual(modelPath);
                                }
                                break;
                            case 'error':
                                console.error('Worker loading error:', error);
                                // 回退到主线程加载
                                loadModelActual(modelPath);
                                break;
                            default:
                                break;
                        }
                    };
                    
                    modelWorker.onerror = function(error) {
                        console.error('Worker error:', error);
                        // 回退到主线程加载
                        isWorkerInitialized = false;
                    };
                    
                    isWorkerInitialized = true;
                } else {
                    console.error('Worker file not found:', workerUrl);
                    isWorkerInitialized = false;
                }
            } catch (error) {
                console.error('Failed to create worker:', error);
                isWorkerInitialized = false;
            }
        }
    }
    
    // 从Web Worker加载模型
    function loadModelFromWorker(modelData) {
        // 这个函数现在不再使用，因为Web Worker无法直接加载Three.js
        // 我们会回退到主线程加载
        console.log('Web Worker模型加载已回退到主线程');
    }

    // 实际的模型加载函数
    function loadModelActual(modelPath = 'models/default_model.glb') {
        // 防止重复加载
        if (isModelLoading) {
            return;
        }
        
        isModelLoading = true;
        
        // 停止之前的自动演示和模型旋转
        isAutoPlaying = false;
        isModelRotating = false;
        
        // 1. 清空场景，只保留必要对象
        const objectsToKeep = [];
        
        scene.traverse((child) => {
            if (child.isLight) {
                objectsToKeep.push(child);
            }
            if (child.userData && child.userData.isShadowCatcher) {
                objectsToKeep.push(child);
            }
        });
        
        // 清空场景
        while (scene.children.length > 0) {
            scene.remove(scene.children[0]);
        }
        
        // 添加回保留的对象
        objectsToKeep.forEach(obj => {
            scene.add(obj);
        });
        
        // 2. 重置所有引用和数组
        model = null;
        materialGroups = { metal: [], paint: [], screen: [], door: [], drawer: [] };
        ddMaterialMeshes = [];
        cabinetDoors = [];
        drawers = [];
        slidingDoors = [];
        
        // 3. 准备加载器
        const loader = new GLTFLoader();
        loader.setDRACOLoader(getDracoLoader());
        loader.setMeshoptDecoder(MeshoptDecoder);
        const isCompressed = /\.gz$/i.test(modelPath);
        
        // 4. 显示加载界面
        const loadingEl = document.getElementById('loading');
        loadingEl.style.display = 'flex';
        loadingEl.innerHTML = `
            <div class="spinner"></div>
            <p id="loading-text">${isCompressed ? '正在加载压缩模型...' : '正在加载模型...'}</p>
            <div class="progress-bar-wrap" style="width: 200px; height: 8px; background: rgba(77,171,247,0.2); border-radius: 4px; overflow: hidden;">
                <div id="loading-progress" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4dabf7, #748ffc); border-radius: 4px; transition: width 0.2s;"></div>
            </div>
            <p id="loading-percent" style="font-size: 0.9rem; color: #8a9bb8;">0%</p>
        `;
        setLoadingProgress(0, isCompressed ? '正在加载压缩模型...' : '正在加载模型...');
        
        // 5. 定义加载完成回调
        function onModelLoaded(gltf) {
            // 再次清空场景，确保没有任何残留
            const objectsToKeepFinal = [];
            scene.traverse((child) => {
                if (child.isLight || (child.userData && child.userData.isShadowCatcher)) {
                    objectsToKeepFinal.push(child);
                }
            });
            
            while (scene.children.length > 0) {
                scene.remove(scene.children[0]);
            }
            
            objectsToKeepFinal.forEach(obj => scene.add(obj));
            
            // 添加新模型
            model = gltf.scene;
            scene.add(model);
            
            // 处理模型
            model.userData.initialRotation = model.rotation.clone();
            
            // 处理材质和识别部件
            processModel(model);
            
            // 缩放和定位模型
            const box = new THREE.Box3().setFromObject(model);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            let scale = window.innerWidth <= 480 ? 5 / maxDim : 7 / maxDim;
            model.scale.setScalar(scale);
            model.position.sub(center.multiplyScalar(scale));
            if (window.innerWidth <= 480) {
                model.position.y += 1.0;
            }
            
            // 更新UI
            const selectedModel = modelList.find(m => m.path === modelPath);
            if (selectedModel) {
                document.getElementById('model-name').textContent = selectedModel.name;
                document.getElementById('model-description').textContent = selectedModel.description;
            }
            
            document.getElementById('model-status').style.backgroundColor = '#10b981';
            document.getElementById('model-status-text').textContent = '模型已加载';
            document.getElementById('loading').style.display = 'none';
            
            // 更新材质和效果
            updateMetalMaterials();
            updatePaintMaterials();
            setTimeout(() => updateShadowPosition(), 100);
            updateLightIntensity();
            updateBloomEffect();
            
            // 模型加载完成后，确保应用阴影模糊滑块的值
            setTimeout(() => {
                const shadowBlurSlider = document.getElementById('shadow-blur-slider');
                if (shadowBlurSlider && mainLight) {
                    const initialBlur = parseFloat(shadowBlurSlider.value);
                    // 始终应用阴影模糊值，永远不为零
                    mainLight.shadow.radius = Math.max(0.1, initialBlur);
                    // 确保软阴影类型正确
                    renderer.shadowMap.type = THREE.VSMShadowMap;
                    // 强制更新阴影贴图
                    if (mainLight.shadow.map) {
                        mainLight.shadow.map.dispose();
                        mainLight.shadow.map = null;
                    }
                    mainLight.shadow.needsUpdate = true;
                }
            }, 200);
            
            // 播放音乐
            playBackgroundMusic();
            
            // 延迟开始模型旋转，让模型完全加载并渲染
            setTimeout(() => {
                isModelRotating = true;
            }, 500);
            
            // 延迟开始自动演示，让用户有时间观察模型
            setTimeout(() => {
                startAutoDemo();
            }, 3000);
            
            // 重置标志
            isModelLoading = false;
        }
        
        // 6. 定义加载错误回调
        function onModelError(error) {
            document.getElementById('loading').innerHTML = `
                <div style="color: #ff6b6b; text-align: center;">
                    <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 10px;"></i>
                    <p>模型加载失败</p>
                    <p style="font-size: 0.8rem; margin-top: 10px;">请确保模型文件位于models目录中</p>
                    <button onclick="window.loadModel('models/default_model.glb')" style="margin-top: 15px; padding: 8px 15px; background: #4dabf7; border: none; border-radius: 5px; color: white; cursor: pointer;">重新加载</button>
                </div>
            `;
            
            document.getElementById('model-status').style.backgroundColor = '#f59e0b';
            document.getElementById('model-status-text').textContent = '模型加载失败';
            
            // 重置标志
            isModelLoading = false;
        }
        
        // 7. 开始加载模型
        if (isCompressed) {
            const xhr = new XMLHttpRequest();
            xhr.open('GET', modelPath);
            xhr.responseType = 'arraybuffer';
            xhr.onprogress = function(e) {
                if (e.lengthComputable && e.total > 0) {
                    const p = (e.loaded / e.total) * 90;
                    setLoadingProgress(p, '正在下载... ' + Math.round(p) + '%');
                }
            };
            xhr.onload = async function() {
                if (xhr.status !== 200) {
                    onModelError(new Error('HTTP ' + xhr.status));
                    return;
                }
                const compressedBuffer = xhr.response;
                if (!compressedBuffer || compressedBuffer.byteLength === 0) {
                    onModelError(new Error('空文件'));
                    return;
                }
                setLoadingProgress(92, '正在解压...');
                try {
                    let glbBuffer;
                    const data = new Uint8Array(compressedBuffer);
                    if (typeof pako !== 'undefined' && pako.ungzip) {
                        let decompressed = pako.ungzip(data);
                        glbBuffer = decompressed.buffer.slice(decompressed.byteOffset, decompressed.byteOffset + decompressed.byteLength);
                    } else {
                        const stream = new Blob([compressedBuffer]).stream().pipeThrough(new DecompressionStream('gzip'));
                        glbBuffer = await new Response(stream).arrayBuffer();
                    }
                    setLoadingProgress(98, '解析模型...');
                    loader.parse(glbBuffer, '', onModelLoaded, onModelError);
                } catch (err) {
                    onModelError(err);
                }
            };
            xhr.onerror = function() { onModelError(new Error('网络错误')); };
            xhr.send();
        } else {
            loader.load(
                modelPath,
                onModelLoaded,
                function(xhr) {
                    if (xhr.lengthComputable && xhr.total > 0) {
                        const p = (xhr.loaded / xhr.total) * 100;
                        setLoadingProgress(p, '正在加载模型...');
                    }
                },
                onModelError
            );
        }
    }
    
    // 创建内联Web Worker
    function createModelWorker() {
        // Web Worker代码
        const workerCode = `
            self.onmessage = function(e) {
                const { action, modelPath } = e.data;
                
                switch (action) {
                    case 'loadModel':
                        loadModel(modelPath);
                        break;
                    default:
                        console.error('Unknown action:', action);
                }
            };
            
            function loadModel(modelPath) {
                try {
                    // 验证模型路径
                    if (!modelPath || typeof modelPath !== 'string' || modelPath.trim() === '') {
                        self.postMessage({ 
                            type: 'error', 
                            error: '无效的模型路径' 
                        });
                        return;
                    }
                    
                    const isCompressed = /\.gz$/i.test(modelPath);
                    
                    if (isCompressed) {
                        // 处理压缩模型
                        loadModelFile(modelPath, true);
                    } else {
                        // 处理普通模型
                        loadModelFile(modelPath, false);
                    }
                } catch (error) {
                    self.postMessage({ 
                        type: 'error', 
                        error: error.message 
                    });
                }
            }
            
            function loadModelFile(modelPath, isCompressed) {
                try {
                    // 验证URL格式
                    try {
                        new URL(modelPath, self.location.origin);
                    } catch (urlError) {
                        // 如果不是绝对URL，尝试作为相对URL处理
                        // 这里不抛出错误，让xhr尝试加载
                    }
                    
                    const xhr = new XMLHttpRequest();
                    xhr.open('GET', modelPath);
                    xhr.responseType = 'arraybuffer';
                    
                    xhr.onprogress = function(e) {
                        if (e.lengthComputable && e.total > 0) {
                            const progress = isCompressed ? (e.loaded / e.total) * 90 : (e.loaded / e.total) * 100;
                            self.postMessage({ 
                                type: 'progress', 
                                progress: progress, 
                                status: isCompressed ? '正在下载模型...' : '正在加载模型...' 
                            });
                        }
                    };
                    
                    xhr.onload = function() {
                        if (xhr.status !== 200) {
                            self.postMessage({ 
                                type: 'error', 
                                error: 'HTTP ' + xhr.status 
                            });
                            return;
                        }
                        
                        const buffer = xhr.response;
                        if (!buffer || buffer.byteLength === 0) {
                            self.postMessage({ 
                                type: 'error', 
                                error: '空文件' 
                            });
                            return;
                        }
                        
                        if (isCompressed) {
                            self.postMessage({ 
                                type: 'progress', 
                                progress: 92, 
                                status: '正在解压...' 
                            });
                            
                            try {
                                let glbBuffer;
                                const data = new Uint8Array(buffer);
                                
                                // 尝试使用pako解压
                                if (typeof pako !== 'undefined' && pako.ungzip) {
                                    let decompressed = pako.ungzip(data);
                                    glbBuffer = decompressed.buffer.slice(decompressed.byteOffset, decompressed.byteOffset + decompressed.byteLength);
                                } else {
                                    // 尝试使用原生DecompressionStream
                                    const stream = new Blob([buffer]).stream().pipeThrough(new DecompressionStream('gzip'));
                                    new Response(stream).arrayBuffer().then(glbBuffer => {
                                        self.postMessage({ 
                                            type: 'complete', 
                                            buffer: glbBuffer, 
                                            isCompressed: true 
                                        });
                                    }).catch(error => {
                                        self.postMessage({ 
                                            type: 'error', 
                                            error: '解压失败: ' + error.message 
                                        });
                                    });
                                    return;
                                }
                                
                                self.postMessage({ 
                                    type: 'complete', 
                                    buffer: glbBuffer, 
                                    isCompressed: true 
                                });
                            } catch (err) {
                                self.postMessage({ 
                                    type: 'error', 
                                    error: '解压失败: ' + err.message 
                                });
                            }
                        } else {
                            self.postMessage({ 
                                type: 'complete', 
                                buffer: buffer, 
                                isCompressed: false 
                            });
                        }
                    };
                    
                    xhr.onerror = function() {
                        self.postMessage({ 
                            type: 'error', 
                            error: '网络错误' 
                        });
                    };
                    
                    xhr.send();
                } catch (error) {
                    self.postMessage({ 
                        type: 'error', 
                        error: error.message 
                    });
                }
            }
        `;
        
        // 创建Blob URL
        const blob = new Blob([workerCode], { type: 'application/javascript' });
        const workerUrl = URL.createObjectURL(blob);
        
        // 创建Web Worker
        return new Worker(workerUrl);
    }

    // 全局Web Worker引用
    let currentModelWorker = null;
    
    // 加载模型函数（支持 .glb、.glb.gz 及 Draco 压缩网格）
    function loadModel(modelPath = 'models/default_model.glb') {
        // 显示加载界面
        const loadingEl = document.getElementById('loading');
        loadingEl.style.display = 'flex';
        loadingEl.innerHTML = `
            <div class="spinner"></div>
            <p id="loading-text">正在加载模型...</p>
            <div class="progress-bar-wrap" style="width: 200px; height: 8px; background: rgba(77,171,247,0.2); border-radius: 4px; overflow: hidden;">
                <div id="loading-progress" style="height: 100%; width: 0%; background: linear-gradient(90deg, #4dabf7, #748ffc); border-radius: 4px; transition: width 0.2s;"></div>
            </div>
            <p id="loading-percent" style="font-size: 0.9rem; color: #8a9bb8;">0%</p>
        `;
        setLoadingProgress(0, '正在准备加载...');
        
        // 终止之前的Web Worker
        if (currentModelWorker) {
            try {
                currentModelWorker.terminate();
            } catch (error) {
                console.error('Error terminating worker:', error);
            }
            currentModelWorker = null;
        }
        
        try {
            // 创建内联Web Worker
            const modelWorker = createModelWorker();
            currentModelWorker = modelWorker;
            
            modelWorker.onmessage = function(e) {
                const { type, progress, status, buffer, isCompressed, error } = e.data;
                
                switch (type) {
                    case 'progress':
                        setLoadingProgress(progress, status);
                        break;
                    case 'complete':
                        // 模型加载完成，在主线程中处理
                        loadModelFromBuffer(buffer, isCompressed, modelPath);
                        // 终止Web Worker
                        if (currentModelWorker === modelWorker) {
                            try {
                                modelWorker.terminate();
                                currentModelWorker = null;
                            } catch (error) {
                                console.error('Error terminating worker:', error);
                            }
                        }
                        break;
                    case 'error':
                        console.error('Worker loading error:', error);
                        // 回退到主线程加载
                        loadModelActual(modelPath);
                        // 终止Web Worker
                        if (currentModelWorker === modelWorker) {
                            try {
                                modelWorker.terminate();
                                currentModelWorker = null;
                            } catch (error) {
                                console.error('Error terminating worker:', error);
                            }
                        }
                        break;
                    default:
                        break;
                }
            };
            
            modelWorker.onerror = function(error) {
                console.error('Worker error:', error);
                // 回退到主线程加载
                loadModelActual(modelPath);
                // 终止Web Worker
                if (currentModelWorker === modelWorker) {
                    try {
                        modelWorker.terminate();
                        currentModelWorker = null;
                    } catch (error) {
                        console.error('Error terminating worker:', error);
                    }
                }
            };
            
            // 发送加载请求
            modelWorker.postMessage({ action: 'loadModel', modelPath: modelPath });
        } catch (error) {
            console.error('Error creating worker:', error);
            // 回退到主线程加载
            loadModelActual(modelPath);
        }
    }
    
    // 从Buffer加载模型
    function loadModelFromBuffer(buffer, isCompressed, modelPath) {
        // 防止重复加载
        if (isModelLoading) {
            return;
        }
        
        isModelLoading = true;
        
        // 停止之前的自动演示和模型旋转
        isAutoPlaying = false;
        isModelRotating = false;
        
        // 1. 清空场景，只保留必要对象
        const objectsToKeep = [];
        
        scene.traverse((child) => {
            if (child.isLight) {
                objectsToKeep.push(child);
            }
            if (child.userData && child.userData.isShadowCatcher) {
                objectsToKeep.push(child);
            }
        });
        
        // 清空场景
        while (scene.children.length > 0) {
            scene.remove(scene.children[0]);
        }
        
        // 添加回保留的对象
        objectsToKeep.forEach(obj => {
            scene.add(obj);
        });
        
        // 2. 重置所有引用和数组
        model = null;
        materialGroups = { metal: [], paint: [], screen: [], door: [], drawer: [] };
        ddMaterialMeshes = [];
        cabinetDoors = [];
        drawers = [];
        slidingDoors = [];
        
        // 3. 准备加载器
        const loader = new GLTFLoader();
        loader.setDRACOLoader(getDracoLoader());
        loader.setMeshoptDecoder(MeshoptDecoder);
        
        // 4. 显示加载界面
        const loadingEl = document.getElementById('loading');
        loadingEl.style.display = 'flex';
        loadingEl.innerHTML = `
            <div class="spinner"></div>
            <p id="loading-text">${isCompressed ? '正在加载压缩模型...' : '正在加载模型...'}</p>
            <div class="progress-bar-wrap" style="width: 200px; height: 8px; background: rgba(77,171,247,0.2); border-radius: 4px; overflow: hidden;">
                <div id="loading-progress" style="height: 100%; width: 95%; background: linear-gradient(90deg, #4dabf7, #748ffc); border-radius: 4px; transition: width 0.2s;"></div>
            </div>
            <p id="loading-percent" style="font-size: 0.9rem; color: #8a9bb8;">95%</p>
        `;
        setLoadingProgress(95, '正在解析模型...');
        
        // 5. 解析模型
        loader.parse(buffer, '', 
            function(gltf) {
                // 再次清空场景，确保没有任何残留
                const objectsToKeepFinal = [];
                scene.traverse((child) => {
                    if (child.isLight || (child.userData && child.userData.isShadowCatcher)) {
                        objectsToKeepFinal.push(child);
                    }
                });
                
                while (scene.children.length > 0) {
                    scene.remove(scene.children[0]);
                }
                
                objectsToKeepFinal.forEach(obj => scene.add(obj));
                
                // 添加新模型
                model = gltf.scene;
                scene.add(model);
                
                // 处理模型
                model.userData.initialRotation = model.rotation.clone();
                
                // 处理材质和识别部件
                processModel(model);
                
                // 缩放和定位模型
                const box = new THREE.Box3().setFromObject(model);
                const center = box.getCenter(new THREE.Vector3());
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                let scale = window.innerWidth <= 480 ? 5 / maxDim : 7 / maxDim;
                model.scale.setScalar(scale);
                model.position.sub(center.multiplyScalar(scale));
                if (window.innerWidth <= 480) {
                    model.position.y += 1.0;
                }
                
                // 更新UI
                const selectedModel = modelList.find(m => m.path === modelPath);
                if (selectedModel) {
                    document.getElementById('model-name').textContent = selectedModel.name;
                    document.getElementById('model-description').textContent = selectedModel.description;
                }
                
                document.getElementById('model-status').style.backgroundColor = '#10b981';
                document.getElementById('model-status-text').textContent = '模型已加载';
                document.getElementById('loading').style.display = 'none';
                
                // 更新材质和效果
                updateMetalMaterials();
                updatePaintMaterials();
                setTimeout(() => updateShadowPosition(), 100);
                updateLightIntensity();
                updateBloomEffect();
                
                // 模型加载完成后，确保应用阴影模糊滑块的值
                setTimeout(() => {
                    const shadowBlurSlider = document.getElementById('shadow-blur-slider');
                    if (shadowBlurSlider && mainLight) {
                        const initialBlur = parseFloat(shadowBlurSlider.value);
                        // 始终应用阴影模糊值，永远不为零
                        mainLight.shadow.radius = Math.max(0.1, initialBlur);
                        // 确保软阴影类型正确
                        renderer.shadowMap.type = THREE.VSMShadowMap;
                        // 强制更新阴影贴图
                        if (mainLight.shadow.map) {
                            mainLight.shadow.map.dispose();
                            mainLight.shadow.map = null;
                        }
                        mainLight.shadow.needsUpdate = true;
                    }
                }, 200);
                
                // 播放音乐
                playBackgroundMusic();
                
                // 延迟开始模型旋转，让模型完全加载并渲染
                setTimeout(() => {
                    isModelRotating = true;
                }, 500);
                
                // 延迟开始自动演示，让用户有时间观察模型
                setTimeout(() => {
                    startAutoDemo();
                }, 3000);
                
                // 重置标志
                isModelLoading = false;
            },
            function(xhr) {
                // 解析进度
                const progress = 95 + (xhr.loaded / xhr.total) * 5;
                setLoadingProgress(progress, '正在解析模型...');
            },
            function(error) {
                console.error('Error loading model:', error);
                document.getElementById('loading').innerHTML = `
                    <div style="color: #ff6b6b; text-align: center;">
                        <i class="fas fa-exclamation-triangle" style="font-size: 2rem; margin-bottom: 10px;"></i>
                        <p>模型加载失败</p>
                        <p style="font-size: 0.8rem; margin-top: 10px;">请确保模型文件位于models目录中</p>
                        <button onclick="window.loadModel('models/default_model.glb')" style="margin-top: 15px; padding: 8px 15px; background: #4dabf7; border: none; border-radius: 5px; color: white; cursor: pointer;">重新加载</button>
                    </div>
                `;
                
                document.getElementById('model-status').style.backgroundColor = '#f59e0b';
                document.getElementById('model-status-text').textContent = '模型加载失败';
                
                // 重置标志
                isModelLoading = false;
            }
        );
    }
    
    // 检测本地models文件夹中的模型文件
    function detectLocalModels() {
        return new Promise((resolve) => {
            const potentialModels = [
                { id: 'default', name: '默认模型', description: '演示用默认模型', path: 'models/default_model.glb' },
                { id: 'model1', name: '模型1', description: '现代简约风格设计', path: 'models/model1.glb' },
                { id: 'model2', name: '模型2', description: '工业风格坚固耐用', path: 'models/model2.glb' },
                { id: 'model3', name: '模型3', description: '科技感智能设备', path: 'models/model3.glb' },
                { id: 'model4', name: '模型4', description: '医疗设备专用', path: 'models/model4.glb' },
                { id: 'model5', name: '模型5', description: '多功能操作台', path: 'models/model5.glb' },
                { id: 'model6', name: '模型6', description: '专业级操作台', path: 'models/model6.glb' }
            ];
            
            const validModels = [];
            let checkedCount = 0;
            const totalModels = potentialModels.length;
            
            potentialModels.forEach((modelItem) => {
                const xhr = new XMLHttpRequest();
                xhr.open('HEAD', modelItem.path);
                xhr.onload = function() {
                    if (xhr.status === 200) {
                        validModels.push(modelItem);
                    }
                    checkedCount++;
                    if (checkedCount === totalModels) {
                        modelList = validModels;
                        resolve(validModels);
                    }
                };
                xhr.onerror = function() {
                    checkedCount++;
                    if (checkedCount === totalModels) {
                        modelList = validModels;
                        resolve(validModels);
                    }
                };
                xhr.send();
            });
        });
    }
    
    // 初始化模型选择器
    async function initModelSelector() {
        const modelSelect = document.getElementById('model-select');
        
        // 显示加载状态
        modelSelect.innerHTML = '<option value="" disabled selected>检测模型中...</option>';
        
        try {
            // 检测本地模型
            await detectLocalModels();
            
            // 清空现有选项
            modelSelect.innerHTML = '<option value="" disabled selected>选择模型...</option>';
            
            // 添加模型选项
            if (modelList.length > 0) {
                modelList.forEach((modelItem, index) => {
                    const option = document.createElement('option');
                    option.value = modelItem.path;
                    option.textContent = modelItem.name;
                    modelSelect.appendChild(option);
                });
                // 设置第一个选项为默认选中
                if (modelSelect.options.length > 0) {
                    modelSelect.options[0].selected = true;
                }
            } else {
                // 如果没有检测到模型，添加一个默认选项
                const option = document.createElement('option');
                option.value = 'models/default_model.glb';
                option.textContent = '默认模型（尝试加载）';
                modelSelect.appendChild(option);
            }
        } catch (error) {
            console.error('检测模型时出错:', error);
            // 出错时添加默认选项
            modelSelect.innerHTML = '<option value="" disabled selected>选择模型...</option>';
            const option = document.createElement('option');
            option.value = 'models/default_model.glb';
            option.textContent = '默认模型';
            option.selected = true;
            modelSelect.appendChild(option);
        }
        
        // 添加事件监听
        modelSelect.addEventListener('change', function() {
            const selectedPath = this.value;
            if (selectedPath) {
                loadModel(selectedPath);
            }
        });
    }
    
    // 初始化HDR选择器
    function initHDRSelector() {
        const hdrSelect = document.getElementById('hdr-select');
        
        // 清空现有选项
        hdrSelect.innerHTML = '<option value="" disabled selected>选择环境贴图...</option>';
        
        // 添加环境贴图选项
        envMapList.forEach((envItem) => {
            const option = document.createElement('option');
            option.value = envItem.path;
            option.textContent = envItem.name;
            hdrSelect.appendChild(option);
        });
        
        // 添加事件监听
        hdrSelect.addEventListener('change', function() {
            const selectedPath = this.value;
            const selectedEnv = envMapList.find(env => env.path === selectedPath);
            
            if (selectedPath) {
                loadHDRTexture(selectedPath, selectedEnv.name);
            } else {
                // 恢复默认环境
                clearEnvMap();
                document.getElementById('hdr-info').classList.remove('visible');
                document.getElementById('current-hdr-name').textContent = '默认环境';
            }
        });
    }
    
    // 专门识别柜门、抽屉和推拉门（函数）

    
    // 关键函数：保留烘焙贴图材质
    function preserveBakedMaterial(mesh, type) {
        if (!mesh.material) return;
        
        const originalMaterial = mesh.material;
        
        // 检查是否有贴图（烘焙贴图的标志）
        const hasTexture = originalMaterial.map || 
                          originalMaterial.emissiveMap || 
                          originalMaterial.roughnessMap || 
                          originalMaterial.metalnessMap ||
                          originalMaterial.normalMap ||
                          originalMaterial.aoMap;
        
        // 对屏幕保留烘焙贴图
        if (type === 'screen' && hasTexture) {
            // 保存原始材质
            mesh.userData.originalMaterial = originalMaterial.clone();
            mesh.userData.hasBakedTexture = true;
            
            // 创建增强材质（基于原始烘焙材质）
            createEnhancedBakedMaterial(mesh, type);
        } 
        // 对有纹理的门和抽屉，保留原始纹理
        else if ((type === 'cabinetDoor' || type === 'slidingDoor' || type === 'drawer') && hasTexture) {
            // 保存原始材质
            mesh.userData.originalMaterial = originalMaterial.clone();
            mesh.userData.hasBakedTexture = true;
            
            // 直接使用原始材质，不创建新材质
            // 这样可以确保所有原始属性都被保留
            
            // 确保使用标准材质
            if (!(mesh.material instanceof THREE.MeshStandardMaterial)) {
                const newMaterial = new THREE.MeshStandardMaterial();
                // 复制所有可转移的属性
                Object.assign(newMaterial, mesh.material);
                // 复制贴图
                newMaterial.map = mesh.material.map;
                newMaterial.emissiveMap = mesh.material.emissiveMap;
                newMaterial.roughnessMap = mesh.material.roughnessMap;
                newMaterial.metalnessMap = mesh.material.metalnessMap;
                newMaterial.normalMap = mesh.material.normalMap;
                newMaterial.aoMap = mesh.material.aoMap;
                mesh.material = newMaterial;
            }
            
            // 环境贴图会在loadHDRTexture函数中统一添加
            // 这里只需要确保材质是标准材质即可
            mesh.material.needsUpdate = true;
        }
        // 其他类型或无烘焙贴图，完全保留原始材质
        else {
            // 保存原始材质
            mesh.userData.originalMaterial = mesh.material.clone();
            
            // 不进行任何增强，使用模型中定义的原始材质
            // 只设置阴影属性
            mesh.castShadow = true;
            mesh.receiveShadow = true;
        }
    }
    
    // 创建增强的烘焙材质（保留贴图）
    function createEnhancedBakedMaterial(mesh, type) {
        try {
            const originalMaterial = mesh.userData.originalMaterial;
            
            // 克隆原始材质
            const enhancedMaterial = originalMaterial.clone();
            
            // 轻微增强效果但不破坏贴图
            enhancedMaterial.envMap = envMap;
            enhancedMaterial.envMapIntensity = 0.3;
            enhancedMaterial.needsUpdate = true;
            
            // 根据类型设置额外属性
            if (type === 'cabinetDoor') {
                enhancedMaterial.side = THREE.DoubleSide; // 柜门需要双面显示
            }
            
            // 应用增强材质
            mesh.material = enhancedMaterial;
            
            // 确保网格启用阴影
            mesh.castShadow = true;
            mesh.receiveShadow = true;
        } catch (error) {
            // 回退到原始材质
            mesh.material = mesh.userData.originalMaterial;
        }
    }
    
    // 合并处理模型材质和识别部件
    function processModel(object) {
        let doorCount = 0;
        let drawerCount = 0;
        let slidingDoorCount = 0;
        let processedCount = 0;
        
        // 辅助函数：检查是否是柜门（支持多种拼写变体）
        function isCabinetDoor(name) {
            return name.includes('cabinetdoor') || 
                   name.includes('cabinnetdoor') || 
                   name.includes('cabinet door') ||
                   (name.includes('door') && name.includes('cabinet'));
        }
        
        // 辅助函数：检查是否是推拉门（包含door但不是柜门）
        function isSlidingDoor(name) {
            return name.includes('door') && !isCabinetDoor(name);
        }
        
        // 首次遍历：处理Group对象
        object.traverse((child) => {
            const childName = child.name ? child.name.toLowerCase() : '';
            const originalName = child.name || '(未命名)';
            
            // 识别柜门Group（先检查是否是父级Group）
            if (isCabinetDoor(childName) && (child.isGroup || child.isObject3D)) {
                // 检查这个Group的子对象中是否也包含柜门
                let hasChildDoors = false;
                child.traverse((grandChild) => {
                    if (grandChild !== child) {
                        const grandChildName = grandChild.name ? grandChild.name.toLowerCase() : '';
                        if (isCabinetDoor(grandChildName)) {
                            hasChildDoors = true;
                        }
                    }
                });
                
                // 如果有子柜门，说明这是父级Group，跳过它
                if (hasChildDoors) {
                    return;
                }
                
                doorCount++;
                
                // 添加用户数据到Group - 保存完整的初始旋转
                child.userData = {
                    type: 'cabinetDoor',
                    initialRotation: child.rotation.clone(),
                    open: false
                };
                
                // 将Group添加到柜门数组
                cabinetDoors.push(child);
                
                // 遍历子网格，设置用户数据以便点击检测
                child.traverse((meshChild) => {
                    if (meshChild.isMesh) {
                        // 保存父组引用
                        meshChild.userData = meshChild.userData || {};
                        meshChild.userData.parentGroup = child;
                        meshChild.userData.type = 'cabinetDoor';
                        
                        // 关键修复：保留网格的烘焙贴图材质
                        preserveBakedMaterial(meshChild, 'cabinetDoor');
                        
                        // 添加到材质组（用于点击检测）
                        materialGroups.door.push(meshChild);
                        processedCount++;
                    }
                });
            }
            
            // 识别抽屉Group（局部坐标：Z 轴向上，Y 轴正向朝向相机，抽屉沿局部 Y 轴移动 -200）
            else if (childName.includes('drawer') && (child.isGroup || child.isObject3D)) {
                drawerCount++;
                
                // 添加用户数据到Group，moveAxis 为局部 Y 轴 (0,1,0)
                child.userData = {
                    type: 'drawer',
                    initialPosition: child.position.clone(),
                    open: false,
                    moveAxis: new THREE.Vector3(0, 1, 0)
                };
                
                // 将Group添加到抽屉数组
                drawers.push(child);
                
                // 遍历子网格，设置用户数据以便点击检测
                child.traverse((meshChild) => {
                    if (meshChild.isMesh) {
                        // 保存父组引用
                        meshChild.userData = meshChild.userData || {};
                        meshChild.userData.parentGroup = child;
                        meshChild.userData.type = 'drawer';
                        
                        // 关键修复：保留网格的烘焙贴图材质
                        preserveBakedMaterial(meshChild, 'drawer');
                        
                        // 添加到材质组（用于点击检测）
                        materialGroups.drawer.push(meshChild);
                        
                        // 根据材质名称分类到对应的材质组
                        const meshName = meshChild.name ? meshChild.name.toLowerCase() : '';
                        if (meshName.includes('metal')) {
                            materialGroups.metal.push(meshChild);
                        } else if (meshName.includes('paint') || meshName.includes('plastic') || meshName.includes('body')) {
                            materialGroups.paint.push(meshChild);
                        }
                        
                        processedCount++;
                    }
                });
            }
            
            // 识别推拉门Group（包含door但不是柜门的名称）
            else if (isSlidingDoor(childName) && (child.isGroup || child.isObject3D)) {
                slidingDoorCount++;
                
                // 判断是左门还是右门，确定移动方向
                const isLeftDoor = childName.includes('left');
                const moveDirection = isLeftDoor ? 1 : -1;
                
                // 添加用户数据到Group，moveAxis 为局部 X 轴 (1,0,0)
                child.userData = {
                    type: 'slidingDoor',
                    initialPosition: child.position.clone(),
                    open: false,
                    moveAxis: new THREE.Vector3(1, 0, 0),
                    moveDistance: 450,
                    moveDirection: moveDirection
                };
                
                // 将推拉门添加到数组中
                slidingDoors.push(child);
                
                // 遍历子网格，设置用户数据以便点击检测
                child.traverse((meshChild) => {
                    if (meshChild.isMesh) {
                        // 保存父组引用
                        meshChild.userData = meshChild.userData || {};
                        meshChild.userData.parentGroup = child;
                        meshChild.userData.type = 'slidingDoor';
                        
                        // 关键修复：保留网格的烘焙贴图材质
                        preserveBakedMaterial(meshChild, 'slidingDoor');
                        
                        // 添加到材质组（用于点击检测）
                        if (!materialGroups.slidingDoor) {
                            materialGroups.slidingDoor = [];
                        }
                        materialGroups.slidingDoor.push(meshChild);
                        processedCount++;
                    }
                });
            }
        });
        
        // 二次遍历：处理独立的Mesh和其他材质
        object.traverse((child) => {
            if (child.isMesh) {
                const meshName = child.name ? child.name.toLowerCase() : '';
                const originalName = child.name || '(未命名)';
                
                // 如果这个Mesh已经通过父组处理过，跳过
                if (child.userData && child.userData.parentGroup) {
                    return;
                }
                
                // 识别独立的柜门Mesh
                if (isCabinetDoor(meshName)) {
                    doorCount++;
                    
                    // 添加到柜门数组
                    cabinetDoors.push(child);
                    
                    // 关键修复：保留网格的烘焙贴图材质
                    preserveBakedMaterial(child, 'cabinetDoor');
                    
                    // 设置用户数据 - 保存完整的初始旋转
                    child.userData = {
                        type: 'cabinetDoor',
                        initialRotation: child.rotation.clone(),
                        open: false
                    };
                    
                    // 添加到材质组
                    materialGroups.door.push(child);
                    processedCount++;
                }
                
                // 识别独立的抽屉Mesh（沿局部 Y 轴移动）
                else if (meshName.includes('drawer')) {
                    drawerCount++;
                    
                    // 关键修复：保留网格的烘焙贴图材质
                    preserveBakedMaterial(child, 'drawer');
                    
                    // 设置用户数据（先确保 userData 存在），moveAxis 为局部 Y 轴 (0,1,0)
                    child.userData = child.userData || {};
                    child.userData.type = 'drawer';
                    child.userData.initialPosition = child.position.clone();
                    child.userData.open = false;
                    child.userData.moveAxis = new THREE.Vector3(0, 1, 0);
                    
                    // 添加到材质组
                    materialGroups.drawer.push(child);
                    processedCount++;
                }
                
                // 识别独立的推拉门Mesh（包含door但不是柜门的名称）
                else if (isSlidingDoor(meshName)) {
                    slidingDoorCount++;
                    
                    // 判断是左门还是右门，确定移动方向
                    const isLeftDoor = meshName.includes('left');
                    const moveDirection = isLeftDoor ? 1 : -1;
                    
                    // 设置用户数据
                    child.userData = {
                        type: 'slidingDoor',
                        initialPosition: child.position.clone(),
                        open: false,
                        moveAxis: new THREE.Vector3(1, 0, 0),
                        moveDistance: 450,
                        moveDirection: moveDirection
                    };
                    
                    // 将推拉门添加到数组中
                    slidingDoors.push(child);
                    
                    // 关键修复：保留网格的烘焙贴图材质
                    preserveBakedMaterial(child, 'slidingDoor');
                    
                    // 添加到材质组
                    if (!materialGroups.slidingDoor) {
                        materialGroups.slidingDoor = [];
                    }
                    materialGroups.slidingDoor.push(child);
                    processedCount++;
                }
                
                // 检测特殊材质 "dd"（灵活匹配）
                else if (originalName.toLowerCase().includes('dd')) {
                    // 添加到数组中
                    ddMaterialMeshes.push(child);
                    // 保存原始材质
                    child.userData = child.userData || {};
                    child.userData.originalMaterial = child.material.clone();
                    
                    // 初始状态：改为暗蓝色半透明材质，确保辉光效果消失
                    const darkBlueMaterial = new THREE.MeshStandardMaterial({
                        color: 0x1a2a3a, // 暗蓝色
                        metalness: 0.1,
                        roughness: 0.8,
                        transparent: true,
                        opacity: 0.7,
                        emissive: 0x0a1a2a,
                        emissiveIntensity: 0.1,
                        side: THREE.DoubleSide
                    });
                    
                    darkBlueMaterial.envMap = envMap;
                    darkBlueMaterial.needsUpdate = true;
                    
                    child.material = darkBlueMaterial;
                    
                    processedCount++;
                }
                
                // 检测屏幕（包含screen的名称，且排除非屏幕物体）
                else if ((meshName.includes('screen') || meshName.includes('display') || meshName.includes('monitor')) && 
                         !meshName.includes('panel') && !meshName.includes('cover') && !meshName.includes('frame')) {
                    // 检查是否有烘焙贴图
                    const hasBakedTexture = hasTexture(child.material);
                    
                    if (hasBakedTexture) {
                        createBakedScreenMaterial(child);
                    } else {
                        applyOriginalScreenMaterial(child);
                    }
                    
                    // 添加到材质组
                    materialGroups.screen.push(child);
                    
                    // 确保显示器正确处理阴影
                    child.castShadow = true;
                    child.receiveShadow = true;
                    
                    child.userData = child.userData || {};
                    child.userData.type = 'screen';
                    processedCount++;
                }
                
                // 其他材质处理
                else {
                    // 检查是否有烘焙贴图
                    const hasBakedTexture = hasTexture(child.material);
                    
                    // 其他有烘焙贴图的部件 - 保留原始烘焙材质
                    if (hasBakedTexture) {
                        // 保存原始材质
                        child.userData = child.userData || {};
                        child.userData.originalMaterial = child.material.clone();
                        child.userData.hasBakedTexture = true;
                        
                        // 直接使用原始材质，不创建新材质
                        // 这样可以确保所有原始属性都被保留
                        
                        // 确保使用标准材质
                        if (!(child.material instanceof THREE.MeshStandardMaterial)) {
                            const newMaterial = new THREE.MeshStandardMaterial();
                            // 复制所有可转移的属性
                            Object.assign(newMaterial, child.material);
                            // 复制贴图
                            newMaterial.map = child.material.map;
                            newMaterial.emissiveMap = child.material.emissiveMap;
                            newMaterial.roughnessMap = child.material.roughnessMap;
                            newMaterial.metalnessMap = child.material.metalnessMap;
                            newMaterial.normalMap = child.material.normalMap;
                            newMaterial.aoMap = child.material.aoMap;
                            child.material = newMaterial;
                        }
                        
                        // 环境贴图会在loadHDRTexture函数中统一添加
                        // 这里只需要确保材质是标准材质即可
                        child.material.needsUpdate = true;
                        
                        // 根据名称分类
                        if (meshName.includes('metal')) {
                            materialGroups.metal.push(child);
                            child.userData.type = 'metal';
                        } else if (meshName.includes('paint') || meshName.includes('plastic') || meshName.includes('body')) {
                            materialGroups.paint.push(child);
                            child.userData.type = 'paint';
                        }
                        
                        processedCount++;
                    }
                    
                    // 原始的非烘焙贴图处理逻辑
                    else {
                        // 保存原始材质
                        child.userData = child.userData || {};
                        child.userData.originalMaterial = child.material.clone();
                        
                        // 不进行任何增强，使用模型中定义的原始材质
                        
                        // 根据名称分类
                        if (meshName.includes('metal')) {
                            materialGroups.metal.push(child);
                            child.userData.type = 'metal';
                        } else if (meshName.includes('paint') || meshName.includes('plastic') || meshName.includes('body')) {
                            materialGroups.paint.push(child);
                            child.userData.type = 'paint';
                        }

                        // 启用阴影
                        child.castShadow = true;
                        child.receiveShadow = true;
                        // 确保几何体计算正确的边界框，这对于阴影投射很重要
                        if (child.geometry) {
                            child.geometry.computeBoundingBox();
                            child.geometry.computeBoundingSphere();
                        }
                        
                        processedCount++;
                    }
                }
            }
        });
    }

    // 检查材质是否有贴图
    function hasTexture(material) {
        if (!material) return false;
        
        // 直接检查常见的贴图类型，避免数组遍历
        return !!(material.map || 
                 material.emissiveMap || 
                 material.roughnessMap || 
                 material.metalnessMap ||
                 material.normalMap ||
                 material.aoMap ||
                 material.lightMap);
    }
    
    // 为烘焙贴图屏幕创建材质
    function createBakedScreenMaterial(mesh) {
        try {
            const originalMaterial = mesh.material;
            const originalColor = originalMaterial.color ? originalMaterial.color.clone() : new THREE.Color(0xffffff);
            
            // 创建关闭状态材质（基于原始材质）
            const offMaterial = originalMaterial.clone();
            offMaterial.color = new THREE.Color(0x5a5a5a); // 浅灰色
            offMaterial.metalness = 0.7; // 增加金属度，增强反光效果
            offMaterial.roughness = 0.3; // 降低粗糙度，使反光更明显
            offMaterial.emissive = new THREE.Color(0x2a2a2a); // 轻微自发光，增加反光
            offMaterial.emissiveIntensity = 0.2; // 低强度自发光
            offMaterial.needsUpdate = true;
            
            // 创建开启状态材质
            const onMaterial = originalMaterial.clone();
            onMaterial.color = originalColor.clone().multiplyScalar(2.5); // 增强亮度
            onMaterial.emissive = new THREE.Color(0xffffff);
            onMaterial.emissiveIntensity = 1.2;
            onMaterial.needsUpdate = true;
            
            // 初始设置为关闭状态
            mesh.material = offMaterial;
            
            // 存储用户数据
            mesh.userData = {
                type: 'screen',
                active: false,
                isBaked: true,
                offMaterial: offMaterial,
                onMaterial: onMaterial,
                originalMaterial: originalMaterial,
                originalColor: originalColor
            };
            
            console.log(`烘焙屏幕材质创建完成: ${mesh.name}`);
        } catch (error) {
            console.error('创建烘焙屏幕材质失败:', error);
            // 回退到普通屏幕处理
            applyOriginalScreenMaterial(mesh);
        }
    }
    
    // 应用屏幕材质
    function applyOriginalScreenMaterial(mesh) {
        try {
            const originalMaterial = mesh.material;
            const originalColor = originalMaterial.color ? originalMaterial.color.clone() : new THREE.Color(0x111122);
            
            // 创建关闭状态材质
            const offMaterial = new THREE.MeshStandardMaterial({
                map: originalMaterial.map,
                color: new THREE.Color(0x5a5a5a), // 浅灰色
                metalness: 0.7, // 增加金属度，增强反光效果
                roughness: 0.3, // 降低粗糙度，使反光更明显
                emissive: new THREE.Color(0x2a2a2a), // 轻微自发光，增加反光
                emissiveIntensity: 0.2, // 低强度自发光
                transparent: originalMaterial.transparent || false,
                opacity: originalMaterial.opacity || 1.0,
                side: THREE.FrontSide
            });
            
            // 创建开启状态材质
            const onMaterial = new THREE.MeshStandardMaterial({
                map: originalMaterial.map,
                color: originalColor.clone().multiplyScalar(screenOnBrightness),
                metalness: 0.05,
                roughness: 0.1,
                emissive: originalColor.clone().multiplyScalar(screenOnBrightness * 0.8),
                emissiveIntensity: 0.8,
                transparent: originalMaterial.transparent || false,
                opacity: originalMaterial.opacity || 1.0,
                side: THREE.FrontSide
            });
            
            // 初始设置为关闭状态
            mesh.material = offMaterial;
            
            // 存储用户数据
            mesh.userData = {
                type: 'screen',
                active: false,
                originalMaterial: originalMaterial,
                offMaterial: offMaterial,
                onMaterial: onMaterial,
                originalMap: originalMaterial.map,
                originalColor: originalColor
            };
        } catch (error) {
            console.error('应用屏幕材质失败:', error);
        }
    }
    
    // 应用金属材质
    function applyMetalMaterial(mesh) {
        const originalColor = mesh.material.color ? mesh.material.color.clone() : new THREE.Color(0xaaaaaa);
        
        mesh.material = new THREE.MeshStandardMaterial({
            color: originalColor,
            metalness: metalness,
            roughness: metalRoughness,
            envMap: envMap
        });
        
        // 存储原始颜色用于后续调整
        mesh.userData = mesh.userData || {};
        mesh.userData.originalColor = originalColor;
    }
    
    // 应用油漆材质
    function applyPaintMaterial(mesh) {
        const originalColor = mesh.material.color ? mesh.material.color.clone() : new THREE.Color(0x1e3a8a);
        
        mesh.material = new THREE.MeshStandardMaterial({
            color: originalColor.clone().multiplyScalar(paintBrightness),
            metalness: 0.3,
            roughness: paintRoughness,
            envMap: envMap
        });
        
        // 存储原始颜色用于后续调整
        mesh.userData = mesh.userData || {};
        mesh.userData.originalColor = originalColor;
    }
    

    
    // 应用柜门材质（仅用于无烘焙贴图的柜门）
    function applyCabinetDoorMaterial(mesh) {
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        mesh.material = new THREE.MeshStandardMaterial({
            color: mesh.material.color || 0x3a4558,
            metalness: 0.4,
            roughness: 0.6,
            transparent: false,
            opacity: 1.0,
            envMapIntensity: 0.3,
            side: THREE.DoubleSide
        });
    }
    
    // 应用抽屉材质（仅用于无烘焙贴图的抽屉）
    function applyDrawerMaterial(mesh) {
        mesh.castShadow = true;
        mesh.receiveShadow = true;
        
        mesh.material = new THREE.MeshStandardMaterial({
            color: mesh.material.color || 0x3a4558,
            metalness: 0.4,
            roughness: 0.6,
            transparent: false,
            opacity: 1.0,
            envMapIntensity: 0.3,
            side: THREE.DoubleSide
        });
    }
    
    // 加载HDR纹理
    function loadHDRTexture(path, name) {
        const hdrLoader = new RGBELoader();
        
        hdrLoader.load(
            path,
            function(texture) {
                envMap = texture;
                envMap.mapping = THREE.EquirectangularReflectionMapping;
                
                scene.traverse((child) => {
                    if (child.isMesh && child.material) {
                        if ((child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) && 
                            child.userData && child.userData.type !== 'screen') {
                            child.material.envMap = envMap;
                            // 对于有烘焙贴图的物体，保持其原始的envMapIntensity设置
                            if (!child.userData.hasBakedTexture) {
                                child.material.envMapIntensity = envIntensity;
                            }
                            child.material.needsUpdate = true;
                        }
                    }
                });
                
                document.getElementById('hdr-info').classList.add('visible');
                document.getElementById('current-hdr-name').textContent = name;
            },
            undefined,
            function(error) {
                console.warn('HDR环境贴图加载失败:', error);
                alert('HDR文件加载失败，请确保文件路径正确');
            }
        );
    }
    
    // 清除环境贴图
    function clearEnvMap() {
        envMap = null;
        
        scene.traverse((child) => {
            if (child.isMesh && child.material) {
                if ((child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) && 
                    child.userData && child.userData.type !== 'screen') {
                    child.material.envMap = null;
                    child.material.needsUpdate = true;
                }
            }
        });
    }
    
    // 更新金属材质
    function updateMetalMaterials() {
        metalness = parseFloat(document.getElementById('metalness-slider').value);
        metalRoughness = parseFloat(document.getElementById('metal-roughness-slider').value);
        
        materialGroups.metal.forEach(mesh => {
            if (mesh.material && mesh.userData) {
                // 对于有烘焙贴图的物体，只更新金属度和粗糙度，保留原始贴图
                mesh.material.metalness = metalness;
                mesh.material.roughness = Math.max(metalRoughness, 0.3);
                mesh.material.needsUpdate = true;
            }
        });
    }
    
    // 更新油漆材质
    function updatePaintMaterials() {
        paintBrightness = parseFloat(document.getElementById('paint-brightness-slider').value);
        paintRoughness = parseFloat(document.getElementById('paint-roughness-slider').value);
        
        materialGroups.paint.forEach(mesh => {
            if (mesh.material && mesh.userData && mesh.userData.originalColor) {
                // 对于有烘焙贴图的物体，只更新粗糙度，保留原始颜色和贴图
                if (!mesh.userData.hasBakedTexture) {
                    mesh.material.color = mesh.userData.originalColor.clone().multiplyScalar(paintBrightness);
                }
                mesh.material.roughness = paintRoughness;
                mesh.material.needsUpdate = true;
            }
        });
    }
    

    
    // 切换所有屏幕
    function toggleAllScreens() {
        if (materialGroups.screen.length === 0) return;
        
        const anyScreenActive = materialGroups.screen.some(screen => screen.userData.active);
        const newActiveState = !anyScreenActive;
        
        materialGroups.screen.forEach(screen => {
            try {
                screen.userData.active = newActiveState;
                
                if (screen.userData.isBaked && screen.userData.offMaterial && screen.userData.onMaterial) {
                    screen.material = newActiveState ? screen.userData.onMaterial : screen.userData.offMaterial;
                } else if (screen.userData.offMaterial && screen.userData.onMaterial) {
                    screen.material = newActiveState ? screen.userData.onMaterial : screen.userData.offMaterial;
                }
                
                if (screen.material) {
                    screen.material.needsUpdate = true;
                }
            } catch (error) {
                console.warn('处理屏幕材质时出错:', screen.name, error);
            }
        });
        
        // 同步切换灯带状态
        toggleAllEmitGlows();
        
        updateBloomEffect();
        
        document.getElementById('interaction-status').style.backgroundColor = newActiveState ? '#10b981' : '#f59e0b';
        document.getElementById('interaction-status-text').textContent = newActiveState ? '屏幕开启' : '屏幕关闭';
    }
    
    // 切换所有灯带（呼吸灯效果）
    function toggleAllEmitGlows(duration = 1000) {
        console.log('=== 开始切换所有灯带 ===');
        console.log('当前dd物体数量:', ddMaterialMeshes.length);
        
        // 检查屏幕状态：如果屏幕是开启的，灯带也应该开启
        console.log('检查屏幕状态，屏幕数量:', materialGroups.screen.length);
        const screenActive = materialGroups.screen.some(screen => {
            const active = screen.userData && screen.userData.active;
            console.log('屏幕:', screen.name, 'active:', active);
            return active;
        });
        const newActiveState = screenActive;
        console.log('最终屏幕状态:', screenActive, '新的灯带状态:', newActiveState);
        
        // 保存所有物体的初始状态
        const objectsToAnimate = [];
        
        // 处理特殊材质 "dd"
        if (ddMaterialMeshes.length > 0) {
            console.log('处理特殊材质dd，共', ddMaterialMeshes.length, '个');
            ddMaterialMeshes.forEach((ddMesh, index) => {
                try {
                    console.log('处理dd物体', index + 1, ':', ddMesh.name);
                    ddMesh.userData.active = newActiveState;
                    
                    // 保存初始状态
                    const initialMaterial = ddMesh.material.clone();
                    let targetMaterial;
                    
                    if (newActiveState) {
                        // 屏幕开启：使用原始材质
                        if (ddMesh.userData.originalMaterial) {
                            targetMaterial = ddMesh.userData.originalMaterial.clone();
                            console.log('使用原始材质:', ddMesh.name);
                        } else {
                            // 如果没有原始材质，使用当前材质
                            targetMaterial = initialMaterial;
                            console.log('没有原始材质，使用当前材质:', ddMesh.name);
                        }
                    } else {
                        // 屏幕关闭：使用暗蓝色半透明材质
                        targetMaterial = new THREE.MeshStandardMaterial({
                            color: 0x1a2a3a, // 暗蓝色
                            metalness: 0.1,
                            roughness: 0.9, // 增加粗糙度
                            emissive: 0x000000,
                            emissiveIntensity: 0,
                            transparent: true,
                            opacity: 0.9 // 增加不透明度
                        });
                        console.log('使用暗蓝色半透明材质:', ddMesh.name);
                    }
                    
                    objectsToAnimate.push({ mesh: ddMesh, initialMaterial, targetMaterial });
                } catch (error) {
                    console.warn('处理dd材质时出错:', ddMesh.name, error);
                }
            });
        } else {
            console.log('未找到dd材质 - 当前模型可能没有dd物体');
            // 尝试重新查找dd物体
            if (model) {
                console.log('尝试重新查找dd物体...');
                let foundCount = 0;
                model.traverse((child) => {
                    if (child.isMesh && child.name && child.name.toLowerCase().includes('dd')) {
                        console.log('重新发现dd物体:', child.name);
                        ddMaterialMeshes.push(child);
                        child.userData = child.userData || {};
                        child.userData.originalMaterial = child.material.clone();
                        foundCount++;
                    }
                });
                console.log('重新查找完成，找到', foundCount, '个dd物体');
            }
        }
        
        // 执行动画
        const startTime = performance.now();
        
        function animate(time) {
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 使用缓动函数，使动画更加平滑
            const easedProgress = progress < 0.5 ? 
                2 * progress * progress : 
                -1 + (4 - 2 * progress) * progress;
            
            // 更新每个物体的材质
            objectsToAnimate.forEach(({ mesh, initialMaterial, targetMaterial }) => {
                try {
                    // 创建新的材质，混合初始和目标材质的属性
                    const currentMaterial = new THREE.MeshStandardMaterial();
                    
                    // 混合颜色
                    currentMaterial.color.lerpColors(initialMaterial.color, targetMaterial.color, easedProgress);
                    
                    // 混合自发光颜色
                    if (initialMaterial.emissive && targetMaterial.emissive) {
                        currentMaterial.emissive.lerpColors(initialMaterial.emissive, targetMaterial.emissive, easedProgress);
                    }
                    
                    // 混合自发光强度
                    currentMaterial.emissiveIntensity = THREE.MathUtils.lerp(
                        initialMaterial.emissiveIntensity || 0,
                        targetMaterial.emissiveIntensity || 0,
                        easedProgress
                    );
                    
                    // 混合金属度
                    currentMaterial.metalness = THREE.MathUtils.lerp(
                        initialMaterial.metalness || 0,
                        targetMaterial.metalness || 0,
                        easedProgress
                    );
                    
                    // 混合粗糙度
                    currentMaterial.roughness = THREE.MathUtils.lerp(
                        initialMaterial.roughness || 0.5,
                        targetMaterial.roughness || 0.5,
                        easedProgress
                    );
                    
                    // 混合不透明度
                    if (targetMaterial.transparent) {
                        currentMaterial.transparent = true;
                        currentMaterial.opacity = THREE.MathUtils.lerp(
                            initialMaterial.opacity || 1,
                            targetMaterial.opacity || 1,
                            easedProgress
                        );
                    }
                    
                    // 应用新材质
                    mesh.material = currentMaterial;
                    mesh.material.needsUpdate = true;
                } catch (error) {
                    console.warn('动画过程中出错:', mesh.name, error);
                }
            });
            
            // 更新辉光效果
            updateBloomEffect();
            
            // 强制渲染
            if (renderer && scene && camera) {
                renderer.render(scene, camera);
            }
            
            if (progress < 1) {
                requestAnimationFrame(animate);
            } else {
                // 动画结束，应用最终材质
                objectsToAnimate.forEach(({ mesh, targetMaterial }) => {
                    try {
                        mesh.material = targetMaterial;
                        mesh.material.needsUpdate = true;
                        mesh.updateMatrix();
                        mesh.updateMatrixWorld(true);
                    } catch (error) {
                        console.warn('应用最终材质时出错:', mesh.name, error);
                    }
                });
                
                // 强制渲染
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
                
                console.log('=== 切换所有灯带完成 ===');
            }
        }
        
        // 开始动画
        requestAnimationFrame(animate);
    }
    
    // 自动演示：缓慢打开/关闭所有灯带（呼吸灯效果）
    function autoToggleAllEmitGlows(duration = 1000, targetState = null) {
        return new Promise((resolve) => {
            console.log('=== 开始自动演示灯带切换 ===');
            
            // 确定目标状态
            let newActiveState;
            if (targetState !== null) {
                newActiveState = targetState;
                console.log('使用指定的目标状态:', newActiveState);
            } else {
                // 检查屏幕状态：如果屏幕是开启的，灯带也应该开启
                console.log('检查屏幕状态，屏幕数量:', materialGroups.screen.length);
                const screenActive = materialGroups.screen.some(screen => {
                    const active = screen.userData && screen.userData.active;
                    console.log('屏幕:', screen.name, 'active:', active);
                    return active;
                });
                newActiveState = screenActive;
                console.log('最终屏幕状态:', screenActive, '新的灯带状态:', newActiveState);
            }
            
            // 保存所有物体的初始状态
            const objectsToAnimate = [];
            
            // 处理特殊材质 "dd"
            if (ddMaterialMeshes.length > 0) {
                console.log('自动演示：处理特殊材质dd，共', ddMaterialMeshes.length, '个');
                ddMaterialMeshes.forEach((ddMesh, index) => {
                    try {
                        console.log('自动演示：处理dd物体', index + 1, ':', ddMesh.name);
                        ddMesh.userData.active = newActiveState;
                        
                        // 保存初始状态
                        const initialMaterial = ddMesh.material.clone();
                        let targetMaterial;
                        
                        if (newActiveState) {
                            // 屏幕开启：使用原始材质
                            if (ddMesh.userData.originalMaterial) {
                                targetMaterial = ddMesh.userData.originalMaterial.clone();
                                console.log('自动演示：使用原始材质:', ddMesh.name);
                            } else {
                                // 如果没有原始材质，使用当前材质
                                targetMaterial = initialMaterial;
                                console.log('自动演示：没有原始材质，使用当前材质:', ddMesh.name);
                            }
                        } else {
                            // 屏幕关闭：使用暗蓝色半透明材质
                            targetMaterial = new THREE.MeshStandardMaterial({
                                color: 0x1a2a3a, // 暗蓝色
                                metalness: 0.1,
                                roughness: 0.9, // 增加粗糙度
                                emissive: 0x000000,
                                emissiveIntensity: 0,
                                transparent: true,
                                opacity: 0.9 // 进一步增加不透明度
                            });
                            console.log('自动演示：使用暗蓝色半透明材质:', ddMesh.name);
                        }
                        
                        objectsToAnimate.push({ mesh: ddMesh, initialMaterial, targetMaterial });
                    } catch (error) {
                        console.warn('自动演示：处理dd材质时出错:', ddMesh.name, error);
                    }
                });
            } else {
                console.log('自动演示：未找到dd材质 - 当前模型可能没有dd物体');
                // 尝试重新查找dd物体
                if (model) {
                    console.log('自动演示：尝试重新查找dd物体...');
                    let foundCount = 0;
                    model.traverse((child) => {
                        if (child.isMesh && child.name && child.name.toLowerCase().includes('dd')) {
                            console.log('自动演示：重新发现dd物体:', child.name);
                            ddMaterialMeshes.push(child);
                            child.userData = child.userData || {};
                            child.userData.originalMaterial = child.material.clone();
                            foundCount++;
                        }
                    });
                    console.log('自动演示：重新查找完成，找到', foundCount, '个dd物体');
                    
                    // 如果找到了新的dd物体，重新处理
                    if (foundCount > 0) {
                        console.log('自动演示：处理新发现的dd物体...');
                        ddMaterialMeshes.forEach((ddMesh, index) => {
                            try {
                                console.log('自动演示：处理新发现的dd物体', index + 1, ':', ddMesh.name);
                                ddMesh.userData.active = newActiveState;
                                
                                // 保存初始状态
                                const initialMaterial = ddMesh.material.clone();
                                let targetMaterial;
                                
                                if (newActiveState) {
                                    // 屏幕开启：使用原始材质
                                    if (ddMesh.userData.originalMaterial) {
                                        targetMaterial = ddMesh.userData.originalMaterial.clone();
                                    } else {
                                        targetMaterial = initialMaterial;
                                    }
                                } else {
                                    // 屏幕关闭：使用暗蓝色半透明材质
                                    targetMaterial = new THREE.MeshStandardMaterial({
                                        color: 0x1a2a3a, // 暗蓝色
                                        metalness: 0.1,
                                        roughness: 0.9, // 增加粗糙度
                                        emissive: 0x000000,
                                        emissiveIntensity: 0,
                                        transparent: true,
                                        opacity: 0.9 // 进一步增加不透明度
                                    });
                                }
                                
                                objectsToAnimate.push({ mesh: ddMesh, initialMaterial, targetMaterial });
                            } catch (error) {
                                console.warn('自动演示：处理新发现的dd材质时出错:', ddMesh.name, error);
                            }
                        });
                    }
                }
            }
            

            
            // 执行动画
            const startTime = performance.now();
            
            function animate(time) {
                const elapsed = time - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // 使用缓动函数，使动画更加平滑
                let easedProgress;
                if (newActiveState) {
                    // 开启过程：使用标准缓动函数，使渐亮更自然
                    easedProgress = progress < 0.5 ? 
                        2 * progress * progress : 
                        -1 + (4 - 2 * progress) * progress;
                } else {
                    // 关闭过程：使用更平缓的缓动函数，使渐灭更自然，开始时变化较慢
                    easedProgress = 1 - Math.pow(1 - progress, 3);
                }
                
                // 更新每个物体的材质
                objectsToAnimate.forEach(({ mesh, initialMaterial, targetMaterial }) => {
                    try {
                        // 创建新的材质，混合初始和目标材质的属性
                        const currentMaterial = new THREE.MeshStandardMaterial();
                        
                        // 混合颜色
                        currentMaterial.color.lerpColors(initialMaterial.color, targetMaterial.color, easedProgress);
                        
                        // 混合自发光颜色
                        if (initialMaterial.emissive && targetMaterial.emissive) {
                            currentMaterial.emissive.lerpColors(initialMaterial.emissive, targetMaterial.emissive, easedProgress);
                        }
                        
                        // 混合自发光强度
                        currentMaterial.emissiveIntensity = THREE.MathUtils.lerp(
                            initialMaterial.emissiveIntensity || 0,
                            targetMaterial.emissiveIntensity || 0,
                            easedProgress
                        );
                        
                        // 混合金属度
                        currentMaterial.metalness = THREE.MathUtils.lerp(
                            initialMaterial.metalness || 0,
                            targetMaterial.metalness || 0,
                            easedProgress
                        );
                        
                        // 混合粗糙度
                        currentMaterial.roughness = THREE.MathUtils.lerp(
                            initialMaterial.roughness || 0.5,
                            targetMaterial.roughness || 0.5,
                            easedProgress
                        );
                        
                        // 混合不透明度
                        if (targetMaterial.transparent) {
                            currentMaterial.transparent = true;
                            currentMaterial.opacity = THREE.MathUtils.lerp(
                                initialMaterial.opacity || 1,
                                targetMaterial.opacity || 1,
                                easedProgress
                            );
                        }
                        
                        // 应用新材质
                        mesh.material = currentMaterial;
                        mesh.material.needsUpdate = true;
                    } catch (error) {
                        console.warn('自动演示：动画过程中出错:', mesh.name, error);
                    }
                });
                
                // 更新辉光效果
                updateBloomEffect();
                
                // 强制渲染
                if (renderer && scene && camera) {
                    renderer.render(scene, camera);
                }
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    // 动画结束，应用最终材质
                    objectsToAnimate.forEach(({ mesh, targetMaterial }) => {
                        try {
                            mesh.material = targetMaterial;
                            mesh.material.needsUpdate = true;
                            mesh.updateMatrix();
                            mesh.updateMatrixWorld(true);
                        } catch (error) {
                            console.warn('自动演示：应用最终材质时出错:', mesh.name, error);
                        }
                    });
                    
                    // 强制渲染
                    if (renderer && scene && camera) {
                        renderer.render(scene, camera);
                    }
                    
                    console.log('自动演示：灯带切换动画完成');
                    resolve();
                }
            }
            
            // 开始动画
            requestAnimationFrame(animate);
        });
    }
    
    // 切换柜门状态
    function toggleCabinetDoor(clickedObject, customDuration) {
        if (!clickedObject) return;
        
        console.log('切换柜门:', clickedObject.name, '是否为组:', clickedObject.isGroup);
        
        // 获取实际的柜门对象（如果是网格且有关联的父组，使用父组）
        let actualDoor = clickedObject;
        if (clickedObject.userData && clickedObject.userData.parentGroup) {
            actualDoor = clickedObject.userData.parentGroup;
            console.log('使用父组:', actualDoor.name);
        }
        
        const doorOpen = !actualDoor.userData.open;
        actualDoor.userData.open = doorOpen;
        
        // 从初始旋转开始计算目标旋转
        const targetRotation = actualDoor.userData.initialRotation.clone();
        if (doorOpen) {
            targetRotation.z += doorOpenAngle;
        }
        
        const startRotation = actualDoor.rotation.clone();
        const duration = customDuration || 500;
        
        let startTime = null;
        
        function animateDoor(time) {
            if (!startTime) startTime = time;
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            const easedProgress = progress < 0.5 ? 
                2 * progress * progress : 
                -1 + (4 - 2 * progress) * progress;
            
            // 球面插值完整的旋转
            actualDoor.rotation.x = startRotation.x + (targetRotation.x - startRotation.x) * easedProgress;
            actualDoor.rotation.y = startRotation.y + (targetRotation.y - startRotation.y) * easedProgress;
            actualDoor.rotation.z = startRotation.z + (targetRotation.z - startRotation.z) * easedProgress;
            
            // 强制更新矩阵，确保子对象正确跟随
            actualDoor.updateMatrix();
            actualDoor.updateMatrixWorld(true);
            
            // 更新所有子对象的矩阵
            actualDoor.traverse((child) => {
                if (child.isMesh) {
                    child.updateMatrix();
                    child.updateMatrixWorld(true);
                }
            });
            
            if (progress < 1) {
                requestAnimationFrame(animateDoor);
            } else {
                actualDoor.rotation.copy(targetRotation);
                updateDoorStatus();
            }
        }
        
        requestAnimationFrame(animateDoor);
        updateDoorStatus();
    }
    
    // 带Promise的柜门切换，用于自动演示
    function toggleCabinetDoorPromise(door, customDuration) {
        return new Promise((resolve) => {
            if (!door) {
                resolve();
                return;
            }
            
            // 保存当前状态
            const originalState = door.userData.open;
            
            // 直接调用原始函数
            toggleCabinetDoor(door, customDuration);
            
            // 等待动画完成
            setTimeout(resolve, customDuration + 100);
        });
    }
    
    // 带Promise的抽屉切换，用于自动演示
    function toggleDrawerPromise(drawer, customDuration) {
        return new Promise((resolve) => {
            if (!drawer) {
                resolve();
                return;
            }
            
            // 直接调用原始函数
            toggleDrawer(drawer, customDuration);
            
            // 等待动画完成
            setTimeout(resolve, customDuration + 100);
        });
    }
    
    // 带Promise的推拉门切换，用于自动演示
    function toggleSlidingDoorPromise(door, customDuration) {
        return new Promise((resolve) => {
            if (!door) {
                resolve();
                return;
            }
            
            // 直接调用原始函数
            toggleSlidingDoor(door, customDuration);
            
            // 等待动画完成
            setTimeout(resolve, customDuration + 100);
        });
    }
    
    // 切换抽屉状态（修复版 - 简化方法）
   function toggleDrawer(drawerObject, customDuration) {
    if (!drawerObject) {
        console.warn('未找到抽屉对象');
        return;
    }
    
    console.log('切换抽屉:', drawerObject.name, '是否为组:', drawerObject.isGroup);
    
    // 获取实际的抽屉对象（如果是网格且有关联的父组，使用父组）
    let actualDrawer = drawerObject;
    if (drawerObject.userData && drawerObject.userData.parentGroup) {
        actualDrawer = drawerObject.userData.parentGroup;
        console.log('使用父组:', actualDrawer.name);
    }
    
    const drawerOpen = !actualDrawer.userData.open;
    actualDrawer.userData.open = drawerOpen;
    
    // 确保初始位置设置正确
    if (!actualDrawer.userData.initialPosition) {
        actualDrawer.userData.initialPosition = actualDrawer.position.clone();
        console.log('保存初始位置:', actualDrawer.userData.initialPosition);
    }
    
    // 直接计算目标位置：打开时向下移动200，关闭时回到初始位置
    const targetPosition = actualDrawer.userData.initialPosition.clone();
    if (drawerOpen) {
        // 直接沿Y轴向下移动200
        targetPosition.y -= 200;
    }
    
    console.log(`抽屉${drawerOpen ? '打开' : '关闭'}，目标位置:`, targetPosition.toArray());
    
    // 动画参数
    const startPosition = actualDrawer.position.clone();
    const duration = customDuration || 500;
    let startTime = null;
    
    // 动画函数
    function animateDrawer(time) {
        if (!startTime) startTime = time;
        const elapsed = time - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // 缓动函数
        const easedProgress = progress < 0.5 ? 
            2 * progress * progress : 
            -1 + (4 - 2 * progress) * progress;
        
        // 插值位置
        actualDrawer.position.lerpVectors(startPosition, targetPosition, easedProgress);
        
        // 强制更新矩阵
        actualDrawer.updateMatrix();
        actualDrawer.updateMatrixWorld(true);
        
        if (progress < 1) {
            requestAnimationFrame(animateDrawer);
        } else {
            actualDrawer.position.copy(targetPosition);
            
            // 最终更新矩阵
            actualDrawer.updateMatrix();
            actualDrawer.updateMatrixWorld(true);
            
            console.log(`抽屉${drawerOpen ? '打开' : '关闭'}完成，最终位置:`, actualDrawer.position.toArray());
        }
    }
    
    requestAnimationFrame(animateDrawer);
}

    // 切换推拉门状态（沿局部X轴移动450）
    function toggleSlidingDoor(doorObject, customDuration) {
        if (!doorObject) {
            console.warn('未找到推拉门对象');
            return;
        }
        
        console.log('切换推拉门:', doorObject.name, '是否为组:', doorObject.isGroup);
        
        // 获取实际的推拉门对象（如果是网格且有关联的父组，使用父组）
        let actualDoor = doorObject;
        if (doorObject.userData && doorObject.userData.parentGroup) {
            actualDoor = doorObject.userData.parentGroup;
            console.log('使用父组:', actualDoor.name);
        }
        
        // 确保只处理被点击的推拉门，而不是所有推拉门
        console.log('处理单个推拉门:', actualDoor.name);
        
        const doorOpen = !actualDoor.userData.open;
        actualDoor.userData.open = doorOpen;
        
        if (!actualDoor.userData.initialPosition) {
            // 保存初始局部位置
            actualDoor.userData.initialPosition = actualDoor.position.clone();
            console.log('保存初始位置:', actualDoor.userData.initialPosition);
        }
        
        // 沿局部X轴移动推拉门（直接修改局部X坐标）
        const moveDistance = 450;
        const moveDirection = actualDoor.userData.moveDirection || 1;
        const totalMove = moveDistance * moveDirection;
        
        // 目标位置（基于初始位置）
        const targetPosition = actualDoor.userData.initialPosition.clone();
        if (doorOpen) {
            targetPosition.x += totalMove;
            console.log(`推拉门 ${actualDoor.name} 打开，沿局部X轴移动: ${totalMove} 单位 (方向: ${moveDirection})`);
        } else {
            console.log(`推拉门 ${actualDoor.name} 关闭，回到初始位置`);
        }
        
        console.log('当前位置:', actualDoor.position.toArray());
        console.log('目标位置:', targetPosition.toArray());
        
        // 动画参数
        const startPosition = actualDoor.position.clone();
        const duration = customDuration || 800; // 推拉门动画稍慢一些
        let startTime = null;
        
        // 动画函数
        function animateDoor(time) {
            if (!startTime) startTime = time;
            const elapsed = time - startTime;
            const progress = Math.min(elapsed / duration, 1);
            
            // 缓动函数
            const easedProgress = progress < 0.5 ? 
                2 * progress * progress : 
                -1 + (4 - 2 * progress) * progress;
            
            // 插值位置 - 只更新当前推拉门的位置
            actualDoor.position.lerpVectors(startPosition, targetPosition, easedProgress);
            
            // 强制更新矩阵
            actualDoor.updateMatrix();
            actualDoor.updateMatrixWorld(true);
            
            // 更新所有子对象的矩阵
            actualDoor.traverse((child) => {
                if (child.isMesh) {
                    child.updateMatrix();
                    child.updateMatrixWorld(true);
                }
            });
            
            console.log(`动画进度: ${progress.toFixed(2)}, 当前位置:`, actualDoor.position.toArray());
            
            if (progress < 1) {
                requestAnimationFrame(animateDoor);
            } else {
                actualDoor.position.copy(targetPosition);
                
                // 最终更新矩阵
                actualDoor.updateMatrix();
                actualDoor.updateMatrixWorld(true);
                
                console.log(`推拉门${doorOpen ? '打开' : '关闭'}完成，最终位置:`, actualDoor.position.toArray());
            }
        }
        
        // 使用动画
        requestAnimationFrame(animateDoor);
    }
    

    
    // 更新柜门状态显示
    function updateDoorStatus() {
        const anyDoorOpen = cabinetDoors.some(door => door.userData.open);
        
        const statusElement = document.getElementById('door-status');
        const textElement = document.getElementById('door-status-text');
        
        if (anyDoorOpen) {
            statusElement.style.backgroundColor = '#10b981';
            textElement.textContent = '柜门打开';
        } else {
            statusElement.style.backgroundColor = '#8a9bb8';
            textElement.textContent = '柜门关闭';
        }
    }
    
    // 自动演示：渐亮/渐暗所有屏幕
    function autoToggleAllScreens(duration = 1000) {
        return new Promise(async (resolve) => {
            if (materialGroups.screen.length === 0) {
                resolve();
                return;
            }
            
            const anyScreenActive = materialGroups.screen.some(screen => screen.userData.active);
            const newActiveState = !anyScreenActive;
            
            document.getElementById('interaction-status').style.backgroundColor = newActiveState ? '#10b981' : '#f59e0b';
            document.getElementById('interaction-status-text').textContent = newActiveState ? '屏幕开启' : '屏幕关闭';
            
            // 先更新所有屏幕的状态
            materialGroups.screen.forEach(screen => {
                screen.userData.active = newActiveState;
            });
            
            // 同步切换灯带状态，与屏幕切换完全同步
            await autoToggleAllEmitGlows(duration, newActiveState);
            
            // 对于烘焙材质的屏幕，直接切换材质
            materialGroups.screen.forEach(screen => {
                if (screen.userData.isBaked && screen.userData.offMaterial && screen.userData.onMaterial) {
                    // 烘焙材质：直接切换材质
                    screen.material = newActiveState ? screen.userData.onMaterial : screen.userData.offMaterial;
                } else if (screen.userData.offMaterial && screen.userData.onMaterial) {
                    // 非烘焙材质：直接切换材质
                    screen.material = newActiveState ? screen.userData.onMaterial : screen.userData.offMaterial;
                }
                if (screen.material) {
                    screen.material.needsUpdate = true;
                }
            });
            
            updateBloomEffect();
            resolve();
        });
    }
    

    
    // 重置所有部件到初始状态
    function resetAllParts() {
        console.log('=== 重置所有部件到初始状态 ===');
        
        // 重置模型旋转到初始状态
        if (model && model.userData.initialRotation) {
            model.rotation.copy(model.userData.initialRotation);
            model.updateMatrix();
            model.updateMatrixWorld(true);
        }
    }
    
    // 重置所有部件到初始状态，但保留模型旋转
    function resetAllPartsExceptRotation() {
        console.log('=== 重置所有部件到初始状态（保留模型旋转）===');
        
        // 重置柜门到关闭状态
        cabinetDoors.forEach(door => {
            door.userData.open = false;
            // 复制完整的初始旋转
            if (door.userData.initialRotation) {
                door.rotation.copy(door.userData.initialRotation);
            }
            door.updateMatrix();
            door.updateMatrixWorld(true);
        });
        
        // 重置抽屉到关闭状态
        drawers.forEach(drawer => {
            drawer.userData.open = false;
            if (drawer.userData.initialPosition) {
                drawer.position.copy(drawer.userData.initialPosition);
            }
            drawer.updateMatrix();
            drawer.updateMatrixWorld(true);
        });
        
        // 重置推拉门到关闭状态
        slidingDoors.forEach(door => {
            door.userData.open = false;
            if (door.userData.initialPosition) {
                door.position.copy(door.userData.initialPosition);
            }
            door.updateMatrix();
            door.updateMatrixWorld(true);
        });
        
        // 重置屏幕到关闭状态（直接切换材质，不使用动画）
        materialGroups.screen.forEach(screen => {
            screen.userData.active = false;
            if (screen.userData.offMaterial) {
                screen.material = screen.userData.offMaterial;
            }
            if (screen.material) {
                screen.material.needsUpdate = true;
            }
            console.log('重置屏幕：设置为关闭状态:', screen.name);
        });
        
        // 重置dd物体 - 关闭状态（直接切换材质，不使用动画）
        if (ddMaterialMeshes.length > 0) {
            console.log('重置dd物体，共', ddMaterialMeshes.length, '个');
            ddMaterialMeshes.forEach((ddMesh, index) => {
                ddMesh.userData.active = false;
                if (ddMesh.material) {
                    // 改为暗蓝色半透明材质
                    ddMesh.material = new THREE.MeshStandardMaterial({
                        color: 0x1a2a3a, // 暗蓝色
                        metalness: 0.1,
                        roughness: 0.9, // 增加粗糙度
                        emissive: 0x000000,
                        emissiveIntensity: 0,
                        transparent: true,
                        opacity: 0.9 // 增加不透明度
                    });
                    ddMesh.material.needsUpdate = true;
                    console.log('重置dd物体：改为暗蓝色半透明材质:', ddMesh.name);
                }
            });
        } else {
            console.log('重置时未找到dd材质 - 尝试重新查找');
            // 尝试重新查找dd物体
            if (model) {
                console.log('尝试重新查找dd物体...');
                let foundCount = 0;
                model.traverse((child) => {
                    if (child.isMesh && child.name && child.name.toLowerCase().includes('dd')) {
                        console.log('重新发现dd物体:', child.name);
                        ddMaterialMeshes.push(child);
                        child.userData = child.userData || {};
                        child.userData.originalMaterial = child.material.clone();
                        // 立即设置为关闭状态
                        child.userData.active = false;
                        child.material = new THREE.MeshStandardMaterial({
                            color: 0x1a2a3a, // 暗蓝色
                            metalness: 0.1,
                            roughness: 0.9, // 增加粗糙度
                            emissive: 0x000000,
                            emissiveIntensity: 0,
                            transparent: true,
                            opacity: 0.9 // 增加不透明度
                        });
                        child.material.needsUpdate = true;
                        foundCount++;
                    }
                });
                console.log('重新查找完成，找到', foundCount, '个dd物体');
            }
        }
        
        updateDoorStatus();
        updateBloomEffect();
        document.getElementById('interaction-status').style.backgroundColor = '#f59e0b';
        document.getElementById('interaction-status-text').textContent = '屏幕关闭';
    }
    
    // 同时开关所有柜门
    function autoToggleAllCabinetDoors(open, duration = 1500, forceReset = true) {
        return new Promise((resolve) => {
            if (forceReset) {
                // 确保所有门在正确的初始状态
                cabinetDoors.forEach(door => {
                    if (door.userData.open === open) {
                        // 如果已经是目标状态，快速切换一下重置
                        toggleCabinetDoor(door, 50);
                    }
                });
            } else {
                // 不强制重置，检查是否所有门都已经是目标状态
                const allAlreadyCorrect = cabinetDoors.every(door => door.userData.open === open);
                if (allAlreadyCorrect) {
                    setTimeout(resolve, duration);
                    return;
                }
            }
            
            // 等待一下，然后全部切换到目标状态
            setTimeout(() => {
                Promise.all(cabinetDoors.map(door => toggleCabinetDoorPromise(door, duration)))
                    .then(resolve);
            }, forceReset ? 100 : 0);
        });
    }
    
    // 同时开关所有抽屉
    function autoToggleAllDrawers(open, duration = 1500, forceReset = true) {
        return new Promise((resolve) => {
            if (forceReset) {
                // 确保所有抽屉在正确的初始状态
                drawers.forEach(drawer => {
                    if (drawer.userData.open === open) {
                        // 如果已经是目标状态，快速切换一下重置
                        toggleDrawer(drawer, 50);
                    }
                });
            } else {
                // 不强制重置，检查是否所有抽屉都已经是目标状态
                const allAlreadyCorrect = drawers.every(drawer => drawer.userData.open === open);
                if (allAlreadyCorrect) {
                    setTimeout(resolve, duration);
                    return;
                }
            }
            
            // 等待一下，然后全部切换到目标状态
            setTimeout(() => {
                Promise.all(drawers.map(drawer => toggleDrawerPromise(drawer, duration)))
                    .then(resolve);
            }, forceReset ? 100 : 0);
        });
    }
    
    // 同时开关所有推拉门
    function autoToggleAllSlidingDoors(open, duration = 1800, forceReset = true) {
        return new Promise((resolve) => {
            if (forceReset) {
                // 确保所有推拉门在正确的初始状态
                slidingDoors.forEach(door => {
                    if (door.userData.open === open) {
                        // 如果已经是目标状态，快速切换一下重置
                        toggleSlidingDoor(door, 50);
                    }
                });
            } else {
                // 不强制重置，检查是否所有推拉门都已经是目标状态
                const allAlreadyCorrect = slidingDoors.every(door => door.userData.open === open);
                if (allAlreadyCorrect) {
                    setTimeout(resolve, duration);
                    return;
                }
            }
            
            // 等待一下，然后全部切换到目标状态
            setTimeout(() => {
                Promise.all(slidingDoors.map(door => toggleSlidingDoorPromise(door, duration)))
                    .then(resolve);
            }, forceReset ? 100 : 0);
        });
    }
    
    // 主自动演示函数
    async function startAutoDemo() {
        if (isAutoPlaying) return;
        isAutoPlaying = true;
        
        console.log('=== 开始自动演示 ===');
        
        try {
            // 首先重置所有部件到初始状态，但保留模型旋转
            resetAllPartsExceptRotation();
            
            // 确保模型继续自旋转
            isModelRotating = true;
            console.log('模型继续自旋转（一周约20秒）');
            
            // 等待1秒让用户准备
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 1. 打开屏幕和灯带（1000ms渐亮，同步）
            console.log('步骤1: 打开屏幕和灯带');
            await autoToggleAllScreens(1000);
            
            // 2. 柜门和推拉门同时打开
            console.log('步骤2: 打开柜门和推拉门');
            await autoToggleAllCabinetDoors(true, 1500);
            await autoToggleAllSlidingDoors(true, 1800);
            
            // 3. 抽屉打开
            console.log('步骤3: 打开抽屉');
            await autoToggleAllDrawers(true, 1500);
            
            // 等待2秒，让用户看清所有打开的状态
            await new Promise(resolve => setTimeout(resolve, 2000));
            
            // 4. 依次关闭：抽屉 -> 柜门和推拉门 -> 灯带显示器
            console.log('步骤4: 关闭抽屉');
            await autoToggleAllDrawers(false, 1500);
            
            console.log('步骤5: 关闭柜门和推拉门');
            await autoToggleAllCabinetDoors(false, 1500);
            await autoToggleAllSlidingDoors(false, 1800);
            
            console.log('步骤6: 关闭屏幕和灯带');
            await autoToggleAllScreens(1000);
            
            // 等待1秒，让所有关闭动作完成
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            // 停止模型自旋转
            isModelRotating = false;
            console.log('模型停止自旋转');
            
            console.log('=== 自动演示完成 ===');
        } catch (error) {
            console.error('自动演示出错:', error);
            // 出错时也要停止旋转
            isModelRotating = false;
        } finally {
            isAutoPlaying = false;
        }
    }
    
    // 播放背景音乐
    function playBackgroundMusic() {
        const audio = document.getElementById('bg-music');
        if (!audio) return;
        
        // 直接尝试播放音乐
        if (audio.paused) {
            audio.play().catch(e => {
                console.log('需要用户交互才能播放音频:', e);
            });
        }
    }
    
    // 更新辉光效果
    function updateBloomEffect() {
        if (!bloomPass) return;
        
        bloomPass.strength = bloomEnabled ? bloomStrength : 0;
        bloomPass.threshold = bloomThreshold;
        bloomPass.radius = bloomRadius;
    }
    
    // 创建阴影接收器
    function createShadowCatcher() {
        const shadowCatcherGeometry = new THREE.PlaneGeometry(30, 30);
        const shadowCatcherMaterial = new THREE.ShadowMaterial({
            opacity: 0.25,
            color: 0x1a1a2a,
            transparent: true
        });
        
        shadowCatcher = new THREE.Mesh(shadowCatcherGeometry, shadowCatcherMaterial);
        shadowCatcher.rotation.x = -Math.PI / 2;
        shadowCatcher.position.y = -0.5;
        shadowCatcher.receiveShadow = true;
        shadowCatcher.visible = false;
        shadowCatcher.userData = { isShadowCatcher: true };
        scene.add(shadowCatcher);
    }
    
    // 更新阴影接收器位置
    function updateShadowPosition() {
        if (!shadowCatcher || !model) return;
        
        try {
            const box = new THREE.Box3().setFromObject(model);
            const center = new THREE.Vector3();
            const size = new THREE.Vector3();
            box.getCenter(center);
            box.getSize(size);
            
            const modelBottom = box.min.y;
            
            shadowCatcher.position.set(
                center.x,
                modelBottom - 0.05,
                center.z
            );
            
            const margin = 1.8;
            const targetWidth = Math.max(8, size.x * margin);
            const targetDepth = Math.max(8, size.z * margin);
            
            const scaleX = targetWidth / 30;
            const scaleZ = targetDepth / 30;
            
            shadowCatcher.scale.set(scaleX, 1, scaleZ);
            shadowCatcher.visible = true;
            
            return true;
        } catch (error) {
            console.error('更新阴影位置时出错:', error);
            return false;
        }
    }
    
    // 更新灯光强度 - 修复主光源问题
    function updateLightIntensity() {
        console.log('更新灯光强度 - 主光源:', mainLightIntensity);
        
        // 关键修复：重新设置所有灯光的强度
        if (mainLight) {
            mainLight.intensity = mainLightIntensity;
            console.log('主方向光强度已更新:', mainLight.intensity);
        }
        
        if (pointLight1) {
            pointLight1.intensity = mainLightIntensity * 0.8;
        }
        
        if (pointLight2) {
            pointLight2.intensity = mainLightIntensity * 0.6;
        }
        
        if (pointLight3) {
            pointLight3.intensity = mainLightIntensity * 0.4;
        }
        
        if (leftFillLight) {
            leftFillLight.intensity = leftLightIntensity;
        }
        
        if (rightFillLight) {
            rightFillLight.intensity = rightLightIntensity;
        }
        
        if (ambientLight) {
            ambientLight.intensity = envIntensity;
        }
        
        // 更新所有材质的环境光强度
        scene.traverse((child) => {
            if (child.isMesh && child.material) {
                if ((child.material.isMeshStandardMaterial || child.material.isMeshPhysicalMaterial) && 
                    child.userData && child.userData.type !== 'screen') {
                    child.material.envMapIntensity = envIntensity;
                    child.material.needsUpdate = true;
                }
            }
        });
    }
    
    // 设置星空蓝背景
    function setStarryBlueBackground() {
        const canvas = document.createElement('canvas');
        canvas.width = 2048;
        canvas.height = 1024;
        const ctx = canvas.getContext('2d');
        
        const gradient = ctx.createRadialGradient(
            canvas.width * 0.5, canvas.height * 0.4, 0,
            canvas.width * 0.5, canvas.height * 0.4, Math.max(canvas.width, canvas.height) * 0.6
        );
        
        gradient.addColorStop(0, '#0038a8');
        gradient.addColorStop(0.3, '#00287a');
        gradient.addColorStop(0.6, '#001c5c');
        gradient.addColorStop(0.8, '#001244');
        gradient.addColorStop(1, '#000a2a');
        
        ctx.fillStyle = gradient;
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
        for (let i = 0; i < 200; i++) {
            const x = Math.random() * canvas.width;
            const y = Math.random() * canvas.height;
            const size = Math.random() * 1.5 + 0.5;
            const alpha = Math.random() * 0.6 + 0.4;
            
            ctx.globalAlpha = alpha;
            ctx.beginPath();
            ctx.arc(x, y, size, 0, Math.PI * 2);
            ctx.fill();
        }
        
        ctx.globalAlpha = 1.0;
        
        const texture = new THREE.CanvasTexture(canvas);
        scene.background = texture;
    }
    
    // 设置泛光灯照明系统 - 完全重构
    function setupOmnidirectionalLighting() {
        // 清空现有灯光
        omniLights.forEach(light => scene.remove(light));
        omniLights = [];

// 渲染器阴影配置（必须加，放在光源创建之前）
renderer.shadowMap.enabled = true;
// 使用VSMShadowMap以获得更好的模糊效果
renderer.shadowMap.type = THREE.VSMShadowMap;

// 主方向光（最终优化版）
mainLight = new THREE.DirectionalLight(0xffffff, mainLightIntensity);
mainLight.position.set(8, 15, 10);
mainLight.castShadow = true;

// 提高阴影分辨率，确保细腻的阴影效果
mainLight.shadow.mapSize.width = 1024;
mainLight.shadow.mapSize.height = 1024;

// 优化阴影范围，确保显示器在阴影相机范围内
mainLight.shadow.camera.near = 0.5;
mainLight.shadow.camera.far = 30;
mainLight.shadow.camera.left = -15;
mainLight.shadow.camera.right = 15;
mainLight.shadow.camera.top = 15;
mainLight.shadow.camera.bottom = -5;

// 柔化阴影+微调偏移，解决阴影只有框线的问题
let blurValue = 8; // 默认值
const shadowBlurSlider = document.getElementById('shadow-blur-slider');
if (shadowBlurSlider) {
    blurValue = parseFloat(shadowBlurSlider.value);
} else {
    // 如果滑块还未加载，稍后再尝试设置
    setTimeout(() => {
        const delayedSlider = document.getElementById('shadow-blur-slider');
        if (delayedSlider && mainLight) {
            const initialBlur = parseFloat(delayedSlider.value);
            // 始终应用阴影模糊值，永远不为零
            mainLight.shadow.radius = Math.max(0.1, initialBlur);
            // 强制更新阴影贴图
            if (mainLight.shadow.map) {
                mainLight.shadow.map.dispose();
                mainLight.shadow.map = null;
            }
            mainLight.shadow.needsUpdate = true;
            console.log('延迟应用阴影模糊值:', initialBlur);
        }
    }, 500);
}
// 始终应用阴影模糊值，永远不为零
mainLight.shadow.radius = Math.max(0.1, blurValue);
mainLight.shadow.bias = 0;

scene.add(mainLight);
omniLights.push(mainLight);

// 强制更新阴影贴图以应用初始模糊值
if (mainLight.shadow.map) {
    mainLight.shadow.map.dispose();
    mainLight.shadow.map = null;
}
mainLight.shadow.needsUpdate = true;
console.log('初始化时应用阴影模糊值:', blurValue);
        // 新增：阴影补光（低强度、冷色调，仅填充阴影暗部）
        const shadowFillLight = new THREE.DirectionalLight(0x88ccff, 0.12);
        shadowFillLight.position.set(5, 8, -5);
        shadowFillLight.castShadow = false;
        scene.add(shadowFillLight);
        omniLights.push(shadowFillLight);

        // 点光源1（顶部前方）
        pointLight1 = new THREE.PointLight(0xffffff, mainLightIntensity * 0.8, 15);
        pointLight1.position.set(0, 8, 5);
        pointLight1.castShadow = false;
        scene.add(pointLight1);
        omniLights.push(pointLight1);
        
        // 点光源2（顶部后方）
        pointLight2 = new THREE.PointLight(0xffffff, mainLightIntensity * 0.6, 12);
        pointLight2.position.set(0, 6, -4);
        pointLight2.castShadow = false;
        scene.add(pointLight2);
        omniLights.push(pointLight2);
        
        // 点光源3（顶部侧方）
        pointLight3 = new THREE.PointLight(0xffffff, mainLightIntensity * 0.4, 10);
        pointLight3.position.set(6, 5, 0);
        pointLight3.castShadow = false;
        scene.add(pointLight3);
        omniLights.push(pointLight3);
        
        // 左辅助光（冷色光）
        leftFillLight = new THREE.DirectionalLight(0x88ccff, leftLightIntensity * 0.8);
        leftFillLight.position.set(-5, 3, 3);
        leftFillLight.castShadow = false;
        scene.add(leftFillLight);
        omniLights.push(leftFillLight);
        
        // 右辅助光（冷色光）
        rightFillLight = new THREE.DirectionalLight(0x88ccff, rightLightIntensity * 0.8);
        rightFillLight.position.set(5, 2, -2);
        rightFillLight.castShadow = false;
        scene.add(rightFillLight);
        omniLights.push(rightFillLight);
        
        // 环境光
        ambientLight = new THREE.AmbientLight(0xffffff, envIntensity);
        scene.add(ambientLight);
        omniLights.push(ambientLight);
        
        console.log('灯光系统已设置完成');
        console.log('主方向光位置:', mainLight.position);
        console.log('主方向光强度:', mainLight.intensity);
    }
    
    // 收集模型中所有可参与射线检测的网格（用于只命中最近、不被遮挡的物体）
    function collectAllMeshesForRaycast() {
        const meshes = [];
        if (model) {
            model.traverse((child) => {
                if (child.isMesh) meshes.push(child);
            });
        }
        return meshes;
    }
    
    const INTERACTIVE_TYPES = ['screen', 'emit', 'cabinetDoor', 'drawer', 'slidingDoor'];
    
    // 射线检测：只取最近的一个交点，且仅当该物体为可交互类型时才返回（被非交互物体遮挡则不命中）
    function getFirstHitInteractive() {
        const allMeshes = collectAllMeshesForRaycast();
        if (allMeshes.length === 0) return null;
        raycaster.setFromCamera(mouse, camera);
        const intersects = raycaster.intersectObjects(allMeshes, true);
        if (intersects.length === 0) return null;
        const hit = intersects[0];
        let obj = hit.object;
        while (obj) {
            const t = obj.userData && obj.userData.type;
            if (t && INTERACTIVE_TYPES.includes(t)) {
                return { object: obj, type: t };
            }
            obj = obj.parent;
        }
        return null;
    }
    
    // 处理画布点击事件（只响应未被遮挡的可交互物体）
    function onCanvasClick(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        const hit = getFirstHitInteractive();
        if (!hit) return;
        
        const clickedObject = hit.object;
        const partType = hit.type;
        
        console.log(`点击了: "${clickedObject.name}", 类型: ${partType}`);
        
        // 只处理屏幕和灯带的点击，取消柜门、抽屉和推拉门的点击动作
        if (partType === 'screen') {
            toggleAllScreens();
        } else if (partType === 'emit') {
            toggleAllEmitGlows();
        }
        // 取消以下点击动作，只保留拖动动作
        // } else if (partType === 'cabinetDoor') {
        //     toggleCabinetDoor(clickedObject);
        // } else if (partType === 'drawer') {
        //     toggleDrawer(clickedObject);
        // } else if (partType === 'slidingDoor') {
        //     toggleSlidingDoor(clickedObject);
        // }
    }
    
    // 鼠标移动：更新轮廓高亮（仅对未被遮挡的可交互物体高亮；柜门/抽屉高亮整组）
    function onCanvasMouseMove(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        // 处理拖动
        if (isDragging && draggedObject) {
            handleDrag(event);
            return;
        }
        
        const hit = getFirstHitInteractive();
        const list = outlinePass.selectedObjects;
        list.length = 0;
        if (hit && hit.object) {
            const outlineTarget = (hit.object.userData && hit.object.userData.parentGroup) ? hit.object.userData.parentGroup : hit.object;
            list.push(outlineTarget);
        }
    }
    
    // 处理拖动逻辑
    function handleDrag(event) {
        // 禁用轨道控制器，避免旋转冲突
        controls.enabled = false;
        
        const rect = renderer.domElement.getBoundingClientRect();
        const currentMouseX = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        const currentMouseY = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        const mouseDeltaX = currentMouseX - dragStartMouse.x;
        const mouseDeltaY = currentMouseY - dragStartMouse.y;
        
        const objectType = draggedObject.userData.type;
        
        if (objectType === 'drawer') {
            // 抽屉：向下拖动为开（沿局部Y轴负方向）
            // 确保初始位置设置正确（模型定义的局部坐标0点）
            if (!draggedObject.userData.initialPosition) {
                // 重置为模型定义的初始位置（局部坐标0点）
                draggedObject.userData.initialPosition = draggedObject.position.clone();
                // 记录局部坐标的初始位置为0
                draggedObject.userData.localPositionY = 0;
            }
            
            // 鼠标向下拖动时，沿局部Y轴负向移动（打开）
            // 鼠标向上拖动时，沿局部Y轴正向移动（关闭）
            // 注意：鼠标向下移动时，mouseDeltaY为负值
            const moveDistance = -mouseDeltaY * 700; // 按要求设置灵敏度，负号反转方向
            
            // 计算新的局部位置，确保在0-200范围内（向下为正）
            const currentLocalPosition = draggedObject.userData.localPositionY || 0;
            const newLocalPositionY = Math.max(0, Math.min(200, currentLocalPosition + moveDistance));
            
            // 更新局部位置记录
            draggedObject.userData.localPositionY = newLocalPositionY;
            
            // 应用新的位置
            // 重置到初始全局位置
            draggedObject.position.copy(draggedObject.userData.initialPosition);
            // 沿局部Y轴负向移动（向下）
            draggedObject.translateY(-newLocalPositionY);
            
            draggedObject.userData.open = newLocalPositionY > 100; // 超过一半算打开
        } else if (objectType === 'cabinetDoor') {
            // 柜门：严格执行0-85度范围旋转
            // 基于门的名称检测左右门
            const doorName = draggedObject.name;
            let effectiveMouseDeltaX = mouseDeltaX;
            
            // 检测左右门
            if (doorName.includes('left')) {
                // 左侧门：向左拖动为开（反转鼠标移动方向）
                effectiveMouseDeltaX = -mouseDeltaX;
            } else if (doorName.includes('right')) {
                // 右侧门：向右拖动为开（保持鼠标移动方向）
                effectiveMouseDeltaX = mouseDeltaX;
            }
            
            const rotateAngle = effectiveMouseDeltaX * Math.PI * 0.8; // 提高灵敏度
            const maxAngle = 85 * Math.PI / 180;
            
            // 确保从初始旋转开始计算，而不是从当前旋转
            if (!draggedObject.userData.initialRotation) {
                draggedObject.userData.initialRotation = draggedObject.rotation.clone();
            }
            
            // 计算新的旋转角度，确保在0-85度范围内
            const currentRotation = draggedObject.rotation.z - draggedObject.userData.initialRotation.z;
            const newRotation = Math.max(0, Math.min(maxAngle, currentRotation + rotateAngle));
            
            // 应用新的旋转
            draggedObject.rotation.z = draggedObject.userData.initialRotation.z + newRotation;
            draggedObject.userData.open = newRotation > maxAngle * 0.5; // 超过一半算打开
        } else if (objectType === 'slidingDoor') {
            // 推拉门：沿局部X轴移动，范围0-450
            // 确保初始位置设置正确（模型定义的局部坐标0点）
            if (!draggedObject.userData.initialPosition) {
                // 重置为模型定义的初始位置（局部坐标0点）
                draggedObject.userData.initialPosition = draggedObject.position.clone();
                // 记录局部坐标的初始位置为0
                draggedObject.userData.localPositionX = 0;
            }
            
            // 检测左右门
            const doorName = draggedObject.name;
            
            // 计算移动距离（支持双向移动）
            let moveDistance = mouseDeltaX * 700; // 按要求设置灵敏度
            
            // 对于右门，反转移动距离方向，确保与鼠标拖动方向一致
            if (doorName.includes('right')) {
                moveDistance = -moveDistance;
            }
            
            // 计算新的局部位置，确保在0-450范围内
            const currentLocalPosition = draggedObject.userData.localPositionX || 0;
            const newLocalPositionX = Math.max(0, Math.min(450, currentLocalPosition + moveDistance));
            
            // 更新局部位置记录
            draggedObject.userData.localPositionX = newLocalPositionX;
            
            // 应用新的位置
            // 重置到初始全局位置
            draggedObject.position.copy(draggedObject.userData.initialPosition);
            
            // 根据门的类型应用移动
            if (doorName.includes('right')) {
                // 右门：沿局部X轴负向移动，范围0-450
                draggedObject.translateX(-newLocalPositionX);
            } else {
                // 左门：沿局部X轴正向移动，范围0-450
                draggedObject.translateX(newLocalPositionX);
            }
            
            draggedObject.userData.open = newLocalPositionX > 0; // 大于0就算打开
        }
        
        // 强制更新矩阵
        draggedObject.updateMatrix();
        draggedObject.updateMatrixWorld(true);
    }
    
    // 处理鼠标按下事件
    function onCanvasMouseDown(event) {
        const rect = renderer.domElement.getBoundingClientRect();
        mouse.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
        mouse.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
        
        const hit = getFirstHitInteractive();
        if (!hit) return;
        
        const clickedObject = hit.object;
        const partType = hit.type;
        
        // 只允许拖动柜门、抽屉和推拉门
        if (partType === 'cabinetDoor' || partType === 'drawer' || partType === 'slidingDoor') {
            // 获取实际要拖动的对象（如果是子网格，使用父组）
            draggedObject = (clickedObject.userData && clickedObject.userData.parentGroup) ? clickedObject.userData.parentGroup : clickedObject;
            
            if (draggedObject) {
                isDragging = true;
                dragStartMouse.x = mouse.x;
                dragStartMouse.y = mouse.y;
                dragStartPosition.copy(draggedObject.position);
                dragStartRotation.copy(draggedObject.rotation);
                
                console.log('开始拖动:', draggedObject.name, '类型:', partType);
            }
        }
    }
    
    // 处理鼠标释放事件
    function onCanvasMouseUp(event) {
        if (isDragging && draggedObject) {
            console.log('结束拖动:', draggedObject.name);
        }
        
        // 重新启用轨道控制器
        controls.enabled = true;
        
        isDragging = false;
        draggedObject = null;
    }
    
    // 处理触摸开始事件
    function onCanvasTouchStart(event) {
        if (event.touches.length > 0) {
            const touch = event.touches[0];
            const rect = renderer.domElement.getBoundingClientRect();
            mouse.x = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
            mouse.y = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
            
            const hit = getFirstHitInteractive();
            if (!hit) return;
            
            const clickedObject = hit.object;
            const partType = hit.type;
            
            // 只允许拖动柜门、抽屉和推拉门
            if (partType === 'cabinetDoor' || partType === 'drawer' || partType === 'slidingDoor') {
                // 获取实际要拖动的对象（如果是子网格，使用父组）
                draggedObject = (clickedObject.userData && clickedObject.userData.parentGroup) ? clickedObject.userData.parentGroup : clickedObject;
                
                if (draggedObject) {
                    // 禁用轨道控制器，避免旋转冲突
                    controls.enabled = false;
                    
                    isDragging = true;
                    dragStartMouse.x = mouse.x;
                    dragStartMouse.y = mouse.y;
                    dragStartPosition.copy(draggedObject.position);
                    dragStartRotation.copy(draggedObject.rotation);
                    
                    console.log('开始触摸拖动:', draggedObject.name, '类型:', partType);
                }
            }
        }
    }
    
    // 处理触摸移动事件
    function onCanvasTouchMove(event) {
        if (event.touches.length > 0) {
            const touch = event.touches[0];
            
            // 处理拖动
            if (isDragging && draggedObject) {
                // 禁用轨道控制器，避免旋转冲突
                controls.enabled = false;
                
                const rect = renderer.domElement.getBoundingClientRect();
                const currentMouseX = ((touch.clientX - rect.left) / rect.width) * 2 - 1;
                const currentMouseY = -((touch.clientY - rect.top) / rect.height) * 2 + 1;
                
                const mouseDeltaX = currentMouseX - dragStartMouse.x;
                const mouseDeltaY = currentMouseY - dragStartMouse.y;
                
                const objectType = draggedObject.userData.type;
                
                if (objectType === 'drawer') {
                    // 抽屉：向下拖动为开（沿局部Y轴负方向）
                    // 确保初始位置设置正确（模型定义的局部坐标0点）
                    if (!draggedObject.userData.initialPosition) {
                        // 重置为模型定义的初始位置（局部坐标0点）
                        draggedObject.userData.initialPosition = draggedObject.position.clone();
                        // 记录局部坐标的初始位置为0
                        draggedObject.userData.localPositionY = 0;
                    }
                    
                    // 鼠标向下拖动时，沿局部Y轴负向移动（打开）
                    // 鼠标向上拖动时，沿局部Y轴正向移动（关闭）
                    // 注意：鼠标向下移动时，mouseDeltaY为负值
                    const moveDistance = -mouseDeltaY * 700; // 按要求设置灵敏度，负号反转方向
                    
                    // 计算新的局部位置，确保在0-200范围内（向下为正）
                    const currentLocalPosition = draggedObject.userData.localPositionY || 0;
                    const newLocalPositionY = Math.max(0, Math.min(200, currentLocalPosition + moveDistance));
                    
                    // 更新局部位置记录
                    draggedObject.userData.localPositionY = newLocalPositionY;
                    
                    // 应用新的位置
                    // 重置到初始全局位置
                    draggedObject.position.copy(draggedObject.userData.initialPosition);
                    // 沿局部Y轴负向移动（向下）
                    draggedObject.translateY(-newLocalPositionY);
                    
                    draggedObject.userData.open = newLocalPositionY > 100; // 超过一半算打开
                } else if (objectType === 'cabinetDoor') {
                    // 柜门：严格执行0-85度范围旋转
                    const doorName = draggedObject.name;
                    let effectiveMouseDeltaX = mouseDeltaX;
                    
                    if (doorName.includes('left')) {
                        effectiveMouseDeltaX = -mouseDeltaX;
                    } else if (doorName.includes('right')) {
                        effectiveMouseDeltaX = mouseDeltaX;
                    }
                    
                    const rotateAngle = effectiveMouseDeltaX * Math.PI * 0.8; // 提高灵敏度
                    const maxAngle = 85 * Math.PI / 180;
                    
                    if (!draggedObject.userData.initialRotation) {
                        draggedObject.userData.initialRotation = draggedObject.rotation.clone();
                    }
                    
                    const currentRotation = draggedObject.rotation.z - draggedObject.userData.initialRotation.z;
                    const newRotation = Math.max(0, Math.min(maxAngle, currentRotation + rotateAngle));
                    
                    draggedObject.rotation.z = draggedObject.userData.initialRotation.z + newRotation;
                    draggedObject.userData.open = newRotation > maxAngle * 0.5;
                } else if (objectType === 'slidingDoor') {
                    // 推拉门：沿局部X轴移动，范围0-450
                    if (!draggedObject.userData.initialPosition) {
                        draggedObject.userData.initialPosition = draggedObject.position.clone();
                        draggedObject.userData.localPositionX = 0;
                    }
                    
                    const doorName = draggedObject.name;
                    let moveDistance = mouseDeltaX * 700;
                    
                    if (doorName.includes('right')) {
                        moveDistance = -moveDistance;
                    }
                    
                    const currentLocalPosition = draggedObject.userData.localPositionX || 0;
                    const newLocalPositionX = Math.max(0, Math.min(450, currentLocalPosition + moveDistance));
                    
                    draggedObject.userData.localPositionX = newLocalPositionX;
                    draggedObject.position.copy(draggedObject.userData.initialPosition);
                    
                    if (doorName.includes('right')) {
                        draggedObject.translateX(-newLocalPositionX);
                    } else {
                        draggedObject.translateX(newLocalPositionX);
                    }
                    
                    draggedObject.userData.open = newLocalPositionX > 0;
                }
                
                // 强制更新矩阵
                draggedObject.updateMatrix();
                draggedObject.updateMatrixWorld(true);
                
                return;
            }
        }
    }
    
    // 处理触摸结束事件
    function onCanvasTouchEnd(event) {
        if (isDragging && draggedObject) {
            console.log('结束触摸拖动:', draggedObject.name);
        }
        
        // 重新启用轨道控制器
        controls.enabled = true;
        
        isDragging = false;
        draggedObject = null;
    }
    
    // 窗口大小调整处理
    function onWindowResize() {
        const container = document.getElementById('three-container');
        const w = container.clientWidth;
        const h = container.clientHeight;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
        composer.setSize(w, h);
        if (outlinePass && outlinePass.resolution) outlinePass.resolution.set(w, h);
        if (bloomPass && bloomPass.resolution) bloomPass.resolution.set(w, h);
    }
    
    // 动画循环
    function animate() {
        requestAnimationFrame(animate);
        
        const delta = clock.getDelta();
        
        if (isModelRotating && model) {
            model.rotation.y += modelRotationSpeed * delta;
        }
        
        controls.update();
        composer.render();
    }
    
    // 初始化Three.js场景
    async function init() {
        // 创建场景
        scene = new THREE.Scene();
        
        // 创建相机
        const container = document.getElementById('three-container');
        camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
        camera.position.set(8, 6, 8);
        
        // 创建渲染器
        renderer = new THREE.WebGLRenderer({ 
            antialias: true, 
            alpha: true,
            powerPreference: "high-performance"
        });
        renderer.setSize(container.clientWidth, container.clientHeight);
        
        if (renderer.outputColorSpace !== undefined) {
            renderer.outputColorSpace = THREE.SRGBColorSpace;
        } else if (renderer.outputEncoding !== undefined) {
            renderer.outputEncoding = THREE.sRGBEncoding;
        }
        
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.VSMShadowMap;
        renderer.shadowMap.autoUpdate = true;
        renderer.shadowMap.needsUpdate = true;
        
        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;
        
        // 确保渲染器支持阴影
        renderer.localClippingEnabled = true;
        
        container.appendChild(renderer.domElement);
        
        // 创建轨道控制器
        controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.minDistance = 3;
        controls.maxDistance = 20;
        controls.maxPolarAngle = Math.PI * 0.8;
        
        // 创建后期处理
        composer = new EffectComposer(renderer);
        const renderPass = new RenderPass(scene, camera);
        renderPass.renderToScreen = true; // 确保渲染到屏幕
        composer.addPass(renderPass);
        
        // 轮廓高亮（鼠标悬停可交互物体）
        const outlineSelected = [];
        outlinePass = new OutlinePass(
            new THREE.Vector2(container.clientWidth, container.clientHeight),
            scene,
            camera,
            outlineSelected
        );
        outlinePass.edgeStrength = 2.5;
        outlinePass.edgeGlow = 0.5;
        outlinePass.edgeThickness = 1.5;
        outlinePass.visibleEdgeColor.set('#4dabf7');
        outlinePass.hiddenEdgeColor.set('#2a3f5f');
        composer.addPass(outlinePass);
        
        // 创建辉光效果
        bloomPass = new UnrealBloomPass(
            new THREE.Vector2(container.clientWidth, container.clientHeight),
            bloomStrength,
            bloomRadius,
            bloomThreshold
        );
        composer.addPass(bloomPass);
        
        // 设置泛光灯照明系统
        setupOmnidirectionalLighting();
        
        // 将主要变量暴露到全局作用域，方便调试
        window.mainLight = mainLight;
        window.renderer = renderer;
        window.composer = composer;
        
        // 设置星空蓝背景
        setStarryBlueBackground();
        
        // 创建阴影接收器
        createShadowCatcher();
        
        // 初始化模型选择器（异步）
        await initModelSelector();
        
        // 初始化HDR选择器
        initHDRSelector();
        
        // 添加事件监听
        window.addEventListener('resize', onWindowResize);
        renderer.domElement.addEventListener('click', onCanvasClick);
        renderer.domElement.addEventListener('mousemove', onCanvasMouseMove);
        renderer.domElement.addEventListener('mousedown', onCanvasMouseDown);
        renderer.domElement.addEventListener('mouseup', onCanvasMouseUp);
        renderer.domElement.addEventListener('mouseleave', onCanvasMouseUp);
        
        // 添加触摸事件监听器，支持手机端拖动
        renderer.domElement.addEventListener('touchstart', onCanvasTouchStart);
        renderer.domElement.addEventListener('touchmove', onCanvasTouchMove);
        renderer.domElement.addEventListener('touchend', onCanvasTouchEnd);
        renderer.domElement.addEventListener('touchcancel', onCanvasTouchEnd);
        
        // 强制初始化时应用滑块的阴影模糊值
        setTimeout(() => {
            const shadowBlurSlider = document.getElementById('shadow-blur-slider');
            if (shadowBlurSlider && mainLight) {
                const initialBlur = parseFloat(shadowBlurSlider.value);
                // 始终应用阴影模糊值，永远不为零
                mainLight.shadow.radius = Math.max(0.1, initialBlur);
                // 确保软阴影类型正确
                renderer.shadowMap.type = THREE.VSMShadowMap;
                // 强制更新阴影贴图
                if (mainLight.shadow.map) {
                    mainLight.shadow.map.dispose();
                    mainLight.shadow.map = null;
                }
                mainLight.shadow.needsUpdate = true;
                console.log('初始化阴影模糊值:', initialBlur);
            }
        }, 1000);
        
        // 开始动画循环
        animate();
    }
    
    // 处理播放按钮点击事件
    function handlePlayButtonClick() {
        console.log('=== 开始按钮被点击 ===');
        
        // 隐藏播放按钮覆盖层
        document.getElementById('play-overlay').classList.add('hidden');
        
        // 播放背景音乐（在用户交互后）
        const audio = document.getElementById('bg-music');
        if (audio) {
            // 确保音频已加载
            if (audio.src === '') {
                audio.src = 'bgm.mp3.MP3';
                audio.loop = true;
            }
            audio.muted = false;
            audio.volume = 0.3;
            audio.play().catch(err => {
                console.log('播放音乐失败:', err);
                // 尝试强制播放
                setTimeout(() => {
                    audio.play().catch(e => console.log('再次尝试播放失败:', e));
                }, 100);
            });
        }
        
        // 直接加载默认模型，确保开始按钮后有模型载入
        console.log('加载默认模型...');
        loadModel('models/default_model.glb');
    }
    
    // 初始化UI事件监听
    function initUIEvents() {
        // 播放按钮点击事件
        const playButton = document.getElementById('play-button');
        if (playButton) {
            playButton.addEventListener('click', handlePlayButtonClick);
        }
        
        // 移动端控制面板切换
        const mobileControlsToggle = document.getElementById('mobile-controls-toggle');
        const controlsSection = document.getElementById('controls-section');
        const controlsOverlay = document.getElementById('controls-overlay');
        
        function toggleControls() {
            const isMobile = window.innerWidth <= 1100;
            if (isMobile) {
                controlsSection.classList.toggle('active');
                controlsOverlay.classList.toggle('active');
                document.body.style.overflow = controlsSection.classList.contains('active') ? 'hidden' : '';
            }
        }
        
        if (mobileControlsToggle) {
            mobileControlsToggle.addEventListener('click', toggleControls);
        }
        if (controlsOverlay) {
            controlsOverlay.addEventListener('click', toggleControls);
        }
        
        // 灯光切换按钮
        const toggleLightsBtn = document.getElementById('toggle-lights-btn');
        if (toggleLightsBtn) {
            toggleLightsBtn.addEventListener('click', function() {
                let lightsOn = true;
                omniLights.forEach(light => {
                    light.visible = !light.visible;
                    if (!light.visible) lightsOn = false;
                });
                
                this.innerHTML = lightsOn ? 
                    '<i class="fas fa-lightbulb"></i><span>泛光灯照明</span>' : 
                    '<i class="far fa-lightbulb"></i><span>开启灯光</span>';
            });
        }
        
        // 金属材质滑块
        const metalnessSlider = document.getElementById('metalness-slider');
        if (metalnessSlider) {
            metalnessSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                const metalnessValue = document.getElementById('metalness-value');
                if (metalnessValue) metalnessValue.textContent = value.toFixed(2);
                updateMetalMaterials();
            });
        }
        
        const metalRoughnessSlider = document.getElementById('metal-roughness-slider');
        if (metalRoughnessSlider) {
            metalRoughnessSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                const metalRoughnessValue = document.getElementById('metal-roughness-value');
                if (metalRoughnessValue) metalRoughnessValue.textContent = value.toFixed(2);
                updateMetalMaterials();
            });
        }
        
        // 油漆材质滑块
        const paintBrightnessSlider = document.getElementById('paint-brightness-slider');
        if (paintBrightnessSlider) {
            paintBrightnessSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                const paintBrightnessValue = document.getElementById('paint-brightness-value');
                if (paintBrightnessValue) paintBrightnessValue.textContent = value.toFixed(1);
                updatePaintMaterials();
            });
        }
        
        const paintRoughnessSlider = document.getElementById('paint-roughness-slider');
        if (paintRoughnessSlider) {
            paintRoughnessSlider.addEventListener('input', function() {
                const value = parseFloat(this.value);
                const paintRoughnessValue = document.getElementById('paint-roughness-value');
                if (paintRoughnessValue) paintRoughnessValue.textContent = value.toFixed(2);
                updatePaintMaterials();
            });
        }
        
        // 主光源强度滑块 - 修复版
        const lightIntensitySlider = document.getElementById('light-intensity-slider');
        if (lightIntensitySlider) {
            lightIntensitySlider.addEventListener('input', function() {
                mainLightIntensity = parseFloat(this.value);
                const lightIntensityValue = document.getElementById('light-intensity-value');
                if (lightIntensityValue) lightIntensityValue.textContent = mainLightIntensity.toFixed(1);
                console.log('主光源强度滑块值:', mainLightIntensity);
                updateLightIntensity();
            });
        }
        
        // 左辅助光强度滑块
        const leftLightSlider = document.getElementById('left-light-slider');
        if (leftLightSlider) {
            leftLightSlider.addEventListener('input', function() {
                leftLightIntensity = parseFloat(this.value);
                const leftLightValue = document.getElementById('left-light-value');
                if (leftLightValue) leftLightValue.textContent = leftLightIntensity.toFixed(1);
                updateLightIntensity();
            });
        }
        
        // 右辅助光强度滑块
        const rightLightSlider = document.getElementById('right-light-slider');
        if (rightLightSlider) {
            rightLightSlider.addEventListener('input', function() {
                rightLightIntensity = parseFloat(this.value);
                const rightLightValue = document.getElementById('right-light-value');
                if (rightLightValue) rightLightValue.textContent = rightLightIntensity.toFixed(1);
                updateLightIntensity();
            });
        }
        
        // 环境光强度滑块
        const envIntensitySlider = document.getElementById('env-intensity-slider');
        if (envIntensitySlider) {
            envIntensitySlider.addEventListener('input', function() {
                envIntensity = parseFloat(this.value);
                const envIntensityValue = document.getElementById('env-intensity-value');
                if (envIntensityValue) envIntensityValue.textContent = envIntensity.toFixed(1);
                updateLightIntensity();
            });
        }
        
        // 辉光效果滑块
        const bloomStrengthSlider = document.getElementById('bloom-strength-slider');
        if (bloomStrengthSlider) {
            bloomStrengthSlider.addEventListener('input', function() {
                bloomStrength = parseFloat(this.value);
                const bloomStrengthValue = document.getElementById('bloom-strength-value');
                if (bloomStrengthValue) bloomStrengthValue.textContent = bloomStrength.toFixed(1);
                updateBloomEffect();
            });
        }
        
        const bloomThresholdSlider = document.getElementById('bloom-threshold-slider');
        if (bloomThresholdSlider) {
            bloomThresholdSlider.addEventListener('input', function() {
                bloomThreshold = parseFloat(this.value);
                const bloomThresholdValue = document.getElementById('bloom-threshold-value');
                if (bloomThresholdValue) bloomThresholdValue.textContent = bloomThreshold.toFixed(2);
                updateBloomEffect();
            });
        }
        
        const bloomRadiusSlider = document.getElementById('bloom-radius-slider');
        if (bloomRadiusSlider) {
            bloomRadiusSlider.addEventListener('input', function() {
                bloomRadius = parseFloat(this.value);
                const bloomRadiusValue = document.getElementById('bloom-radius-value');
                if (bloomRadiusValue) bloomRadiusValue.textContent = bloomRadius.toFixed(1);
                updateBloomEffect();
            });
        }
        
        // 辉光启用开关
        const bloomEnabledToggle = document.getElementById('bloom-enabled-toggle');
        if (bloomEnabledToggle) {
            bloomEnabledToggle.addEventListener('change', function() {
                bloomEnabled = this.checked;
                updateBloomEffect();
            });
        }
        

        
        const shadowBlurSlider = document.getElementById('shadow-blur-slider');
        if (shadowBlurSlider) {
            shadowBlurSlider.addEventListener('input', function() {
                const blur = parseFloat(this.value);
                const shadowBlurValue = document.getElementById('shadow-blur-value');
                if (shadowBlurValue) shadowBlurValue.textContent = blur.toFixed(1);
                
                if (mainLight) {
                    // 始终应用阴影模糊值，永远不为零
                    mainLight.shadow.radius = Math.max(0.1, blur);
                    // 强制更新阴影贴图
                    if (mainLight.shadow.map) {
                        mainLight.shadow.map.dispose();
                        mainLight.shadow.map = null;
                    }
                    mainLight.shadow.needsUpdate = true;
                }
            });
        }
        

        
        // 音乐开关
        const toggleMusicBtn = document.getElementById('toggle-music-btn');
        if (toggleMusicBtn) {
            toggleMusicBtn.addEventListener('click', function() {
                const audio = document.getElementById('bg-music');
                let musicOn = true;
                if (audio) {
                    if (audio.paused) {
                        audio.play().catch(e => console.log('播放音乐失败:', e));
                    } else {
                        audio.pause();
                        musicOn = false;
                    }
                }
                
                this.innerHTML = musicOn ? 
                    '<i class="fas fa-music"></i><span>背景音乐</span>' : 
                    '<i class="fas fa-music-slash"></i><span>开启音乐</span>';
            });
        }
        
        // HDR选择器已在initHDRSelector中初始化
    }
    
    // 页面加载完成后初始化
    window.addEventListener('DOMContentLoaded', async () => {
        // 设置音频源
        const audio = document.getElementById('bg-music');
        if (audio) {
            audio.src = 'bgm.mp3.MP3';
            audio.loop = true;
        }
        
        // 初始化UI事件
        initUIEvents();
        
        // 立即初始化Three.js场景（显示星空背景，但不加载模型）
        await init();
        
        // 设置初始滑块值显示
        document.getElementById('light-intensity-value').textContent = mainLightIntensity.toFixed(1);
        document.getElementById('left-light-value').textContent = leftLightIntensity.toFixed(1);
        document.getElementById('right-light-value').textContent = rightLightIntensity.toFixed(1);
        document.getElementById('env-intensity-value').textContent = envIntensity.toFixed(1);
        document.getElementById('bloom-strength-value').textContent = bloomStrength.toFixed(1);
        document.getElementById('bloom-threshold-value').textContent = bloomThreshold.toFixed(2);
        document.getElementById('bloom-radius-value').textContent = bloomRadius.toFixed(1);
    });
    
    // 窗口大小变化时更新移动端显示
    window.addEventListener('resize', function() {
        const isMobile = window.innerWidth <= 1100;
        const controlsSection = document.getElementById('controls-section');
        const controlsOverlay = document.getElementById('controls-overlay');
        
        if (!isMobile && controlsSection.classList.contains('active')) {
            controlsSection.classList.remove('active');
            controlsOverlay.classList.remove('active');
            document.body.style.overflow = '';
        }
    });
    
    // 全局函数
    window.loadModel = loadModel;
    
    </script>
</body>
</html>